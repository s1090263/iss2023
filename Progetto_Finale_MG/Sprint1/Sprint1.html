<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<link rel="stylesheet" href="html/prism.css">
<script src="html/prism.js"></script>
<style type="text/css">
body
{
    margin-left:  10px;
    margin-right: 10px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
	font-size: 93%;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
	border-radius: 10px;
	padding: 5px;
}

top {
	width: 100%;
}


#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 90%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #abe876;
    color: #1632cc;
}
bc{
	font-family: "Arial";
	font-size: 90%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	font-size: 90%;
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	font-size: 90%;
}
pre{
	font-family: "Consolas";
	font-size: 85%;
	background-color: #f5f5f5;
	border: 1.5px solid silver;
	padding: 5px;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	 
    font-size: 18px;
}
k{
    color: #990000;
	font-weight: bold;
	font-size: 90%;
}
h1 {
    font-size: 150%;
    background-color: #b2c0ff;
	padding: 10px;
}

h2 {
    background-color: #9ed8ff;
    font-size: 130%;
}

h3 {
	background-color: #e6ccff;
    font-size: 100%;
}
h4 {
    background-color: #ccffcc;
    font-size: 100%;
	width: 95%;
	border-radius: 5px;
	padding: 2px;
}
h5 {
    background-color: #d5ffb0;
    font-size: 100%;

}
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}
div.remark{
	background-color: #E3F2FD;
    border: 1.5px solid #d5f2ed;
    padding: 15px;
    margin: 10px;
	border-radius: 25px;
}
div.remark-light{
	background-color: #F0FFFF;
    border: 1.5px solid #d5f2ed;
    padding: 15px;
    margin: 10px;
	border-radius: 15px;
}
span.remark{
	background-color: #6b9cff;
    border: 1.5px solid #d5f2ed;
    padding: 1px;
    margin: 5px;
	border-radius: 25px;
	font-size: 120%;
}

table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}

ol, ul, li {
  margin: 0;
  margin-left: 10px;
  padding: 0;
  padding-bottom: 0px;
}

table, th, td {
	border: 1px solid black;
}

img {
	border: 1.5px solid #d5f2ed

}

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

div.wrapdesc{
	width: 90%;
	margin: auto;
}

div.imagedesc{
	width: 85%;
	margin: auto;
}
.blue{
    color: blue;
}
.red{
	color: red;
}
.sep li{
	padding-bottom: 10px;
}
div.sec{
margin-top: 10px;
margin-left: 30px;
margin-right: 30px;
}
.align-center{
	display: block;
	margin-left: auto;
	margin-right: auto;
}
pre.language-java {
      max-width: 800px; /* Adjust the max-width as needed */
      overflow-x: auto;
      display: inline-block; 
	  padding-top: 0em;
	  padding-bottom: 0em;
	  margin-left: 100px;
    }
	
pre{
overflow: auto;
}

.flex-container {
    display: flex;
}

.flex-child {
	width: 50%;
	flex:1;
}  

.flex-child.left {
    margin-right: 20px;
	overflow: hidden;
	 flex-shrink: 0;
}

.flex-child.right {
	padding-top: 20px;
	 flex-shrink: 1;
}

.small{
font-size:65%;
}

.inline{
display: inline-block;
padding: 0px;
}
</style>
    
<head>
   
<title>Sprint1 Giri Matteo</title>

</head>
    
<body>
<div id="top">
<h1>TEMA FINALE SPRINT1<font size="5"></font> </h1>
</div>

<span class="blue"></span> 
<span class="red"><b></b></span> 

<div class="body"> 
<h2>Introduzione</h2>
Nello <a href="../Sprint0/Sprint0v2.html"><span class="red">SPRINT0</span></a> è stata effettuata l'<b>analisi dei requisiti</b> del sistema <span class="blue">ColdStorageService</span>
da realizzare, che si è conclusa con un primo modello del sistema con la seguente architettura:

<blockquote>
<a class="reference internal image-reference" href="../Sprint0/immagini/ArchitetturaLogicaSprint0.png"><img alt="../Sprint0/immagini/ArchitetturaLogicaSprint0.png" class="align-center" src="../Sprint0/immagini/ArchitetturaLogicaSprint0.png" style="width: 30%;" /></a>
</blockquote>

In questo sprint andrò ad affrontare il problema della creazione del <span class="blue"><b>core applicativo</b></span> del sistema.
<h2>Requisiti</h2>
Nello <span class="red">SPRINT1</span> si terrà conto solo dei requisiti associati alle seguenti <b>user-stories</b>:
<div class="sec remark">
<i><b>1.</b> "A <span class="blue">Fridge truck driver</span> uses the <span class="blue">ServiceAcessGUI</span> to send a request to store its load of <span class="red"><b>FW</b></span>  kg. If the request is accepted, the driver 
drives its truck to the <span class="red">INDOOR</span> of the service, before the ticket exipration time <span class="red"><b>TICKETTIME</b></span>."</i>
</br>
</br>
<i><b>2.</b> "When the truck is at the <span class="red">INDOOR</span> of the service, the driver uses the <span class="blue">ServiceAccessGUI</span> to enter the <b>ticket number</b> and waits until the message
 <b>charge taken</b> (sent by the <span class="blue">ColdStorageService</span>) appears on the ServiceAcessGUI. At this point, the truck should leave the  <span class="red">INDOOR</span>."</i>
</br>
</br>
<i><b>3.</b> "When the service accepts a ticket, the <span class="blue">transport trolley</span> reaches the <span class="red">INDOOR</span>, picks up the food, sends the <b>charge taken</b> message and then goes to the <b>ColdRoom</b> to store the food."</i>
</br>
</br>
<i><b>4.</b> "When the deposit action is terminated, the <span class="blue">transport trolley</span> accepts another <b>ticket</b> (if any) or returns to <span class="red">HOME</span>."</i>
</div>

In particolare: si andrà a realizzare il il cuore del sistema sviluppando il <span class="blue">FridgeService</span>, il <span class="blue">TransportTrolley</span> e la <span class="blue">ServiceAccessGUI</span>.
In aggiunta al modello già prodotto precedentemente, si dovranno gestire i problemi del <b>movimento del trolley</b> e <b>interazioni con basicrobot</b> (e <b>deposit action</b>), la gestione di <b>richieste multiple</b> e l'interazione tra i tre componenti principali.
 La parte di GUI della <span class="blue">ServiceAccessGUI</span> verrà ignorata in questo sprint e le interazioni con il <span class="blue">TruckDriver</span> saranno simulate dall'attore che modella la <span class="blue">ServiceAccessGUI</span> che ho già realizzato.
 
<h2>Analisi del problema</h2>
<div class="sec remark-light">
	<span class="remark">KeyPoints - Analisi del problema</span>
	</br>
	</br>
	<ul class="sep">
	<li>E' necessario utilizzare la <b>rappresentazione a griglia</b> della stanza e il concetto di <b>step</b> per sapere dove il <span class="blue">Trolley</span> è posizionato e per poterlo 
	muovere in altre zone della <b>service area</b>.</li>
	<li>Si utilizza il messaggio <b>moverobot</b> del <span class="blue">BasicRobot23</span> per spostare il <span class="blue">Trolley</span> in posizioni specifiche dell'area.</li>
	<li>Per provare ad ovviare al problema delle mosse fallite, si ritenta il posizionamento del robot inviando nuovi messaggi <b>moverobot</b> relativi alla posizione finale del movimento fallito.</li>
	<li>Il <span class="blue">Trolley</span> deve essere informato da qualcuno dell'arrivo di una richiesta. Questo viene fatto dal <span class="blue">FridgeService</span> tramite una richiesta <b>takecharge</b>, la cui risposta viene delegata alla <span class="blue">ServiceAccessGUI</span> per
	evitare di mettere in attesa il servizio. </li>
	<li>Il sistema deve permettere la gestione di richieste multiple. Si sfruttano le code di messaggi degli attori e la direttiva <b>whenTime</b> del linguaggio Qak per permettere al
	robot di prendere in gestione una nuova richiesta dopo il termine della precedente.</li>
	</ul>
</div>
<h3>Il problema del posizionamento del trolley</h3>
<div class="sec remark-light">
	Nel modello dello SPRINT0 i movimenti del <span class="blue">Transport Trolley</span> sono solo simulati. E' necessario trovare un modo per poter muovere il robot in posizioni specifiche della
	<b>service area</b> per permettergli di effettuare tutte le azioni della <b>deposit action</b>.
	</br>
	</br>
	Nello SPRINT0 ho già introdotto il concetto di service area come una <b>griglia</b> con celle di dimensioni <span class="red"><b>RD</b></span> (dimensione del robot):
	<blockquote>
	<a class="reference internal image-reference" href="../Sprint0/immagini/GrigliaRappr.png"><img alt="../Sprint0/immagini/GrigliaRappr.png" class="align-center" src="../Sprint0/immagini/GrigliaRappr.png" style="width: 20%;" /></a>
	</blockquote>
	Introducendo il concetto di <b>step</b> come un movimento elementare del <b>DDR Robot</b> che lo sposta in avanti di una lunghezza <span class="red"><b>RD</b></span> (unità robotica),
	è possibile costruire questa rappresentazione dell'area a celle (di dimensioni RD x RD). Lo <b>step</b> è incluso nel progetto <a href="../html/BasicRobot23.html">BasicRobot23</a> fornito dal committente attraverso un comando <code>step:step(TIME)</code>, dove <span class0"red"><b>TIME</b></span>
	è il tempo necessario in millisecondi per muovere il robot di un'unità robotica.
	</br>
	Questa rappresentazione è necessaria perchè c'è la necessità di sapere in qualche modo dove il robot si trovi nella stanza per farlo spostare in altre zone della stessa.
	</br>
	Per la realizzazione della mappa il committente fornisce il progetto <span class="blue">unibo.mapperQak23</span> (si veda anche <a href="../html/_static/LabPlanner.html">Planner</a>). Il BasicRobot carica la mappa della stanza quando viene inizializzato.
	Nel caso del sistema da realizzare, la mappa avrà una rappresentazione del tipo:
	</br>
	</br>
	<code>
	|r, 1, 1, 1, 1, 1, 1,</br> 
	|1, 1, 1, 1, X, X, 1, </br>
	|1, 1, 1, 1, X, X, 1, </br>
	|1, 1, X, 1, 1, 1, 1, </br>
	|1, 1, 1, 1, 1, 1, 1, </br>
	|X, X, X, X, X, X, X, </br>
	</code>
	</br>
	<ul class="sep">
	<li><b>0</b> denota una cella mai percorsa</li>
	<li><b>1</b> denota una cella libera</li>
	<li><b>X</b> denota un ostacolo</li>
	<li><b>r</b> denota la posizione corrente del robot</li>
	</ul>
	Il <b>BasicRobot23</b> utilizza questa rappresentazione della stanza per poter muovere il robot all'interno dell'area.
</div>
<div class="sec remark-light">
	Rimane ora il problema di far muovere il robot in posizioni specifiche della <b>service area</b>. Un modo per costruire dinamicamente una sequenza di mosse con cui il robot
	può muoversi dalla posizione corrente <b>r</b> a un’altra posizione (libera) sulla mappa, consiste nell’utilizzo di un <b>pianificatore</b> (si veda 
	<a href="../html/_static/LabPlanner.html">Planning</a>) come quello fornito dal committente in <span class="blue">unibo.planner23-1.0.jar</span>. </br>
	E' possibile inviare al basicrobot la richiesta </br><pre class="inline"><code>Request moverobot : moverobot(TARGETX, TARGETY)</code></pre></br> per poter muovere il robot in una posizione specifica (<span class="red">TARGETX</span>,<span class="red">TARGETY</span>)
	 dell'area. Quando si invia questo messaggio al basicrobot, il servizio delega la sua gestione al componente <span class="blue">robotpos</span>, che facendo uso del <b>planner</b>,
	determina un piano di movimento per raggiungere la destinazione, e fa poi uso del componente <span class="blue">planexec</span> per eseguire il piano di mosse. Alla richiesta <b>moverobot</b> 
	possono corrispondere due tipi di risposte:</br><pre class="inline"><code>Reply moverobotdone: moverobotok(ARG)</code></pre></br> che implica la corretta riuscita del piano di mosse, e </br><pre class="inline"><code>Reply moverobotfailed : moverobotfailed(PLANDONE, PLANTODO)</code></pre></br>
    che corrisponde al fallimento del piano. Nell'ultimo caso, vengono ritornati la parte di piano svolta correttamente (<span class="red">PLANDONE</span>) e quella rimasta da svolgere (<span class="red">PLANTODO</span>)(si veda <a href="../html/robotpos.html">robotPos</a> per ulteriori informazioni).
	</br>
	</br>
	Un altro comando utile del basicrobot è </br><pre class="inline"><code>Dispatch setdirection : dir( D )</code></pre></br> che permette di cambiare l'orientamento del robot fornendo come payload
	del messaggio la direzione richiesta (<span class="red">down</span>|<span class="red">up</span>|<span class="red">left</span>|<span class="red">right</span>).
</div>
<div class="sec remark-light">
	Nel caso in cui la richiesta <b>moverobot</b> fallisca, ho deciso di far riprovare l'ultima mossa al robot finchè non riesce. Per fare questo ho introdotto una enum class di utilità chiamata
	<b>MoveType</b>:
	</br>
	<pre style="display:inline-block;">
<code>
enum class MoveType {
    MOVETOINDOOR, //moving action to INDOOR
    MOVETOCR, //moving action to PORT of coldroom
    MOVETOHOME //moving action to HOME
}
</code>
</pre>
</br>
Tramite questa classe mi salvo in una variabile <b>LastAction</b> l'ultima azione di movimento provata ad eseguire. Quando arriva la risposta <b>moverobotfailed</b> il <span class="blue">Trolley</span>
passa a uno stato <b>tryAgain</b> dove in base al valore di LastAction riprova ad effettuare l'azione. Questo viene fatto a un massimo di <span class="red">N</span> mosse fallite, oltre le quali
il sistema si chiude per troppi errori.

	
</div>

<h3>Interazione tra i componenti del sistema</h3>
<div class="sec remark-light">
Il <span class="blue">Transport Trolley</span> deve in qualche modo essere informato di una richiesta di cui prendersi carico. Questo passaggio viene effettuato dal <span class="blue">FridgeService</span>
che invia la richiesta </br><pre class="inline"><code>Request takecharge : takecharge(TICKET)</code></pre></br> al trolley aspettandosi la risposta </br><pre class="inline"><code>Reply chargetaken : chargetaken(_)</code></pre></br>
Questo tipo di interazione non congestiona il servizio perchè anche se il <span class="blue">FridgeService</span> deve mettersi in attesa di una risposta dal robot, anche la <span class="blue">ServiceAccessGUI</span>
sarà in attesa di una risposta dal servizio, e quindi  in quel lasso di tempo il servizio non potrebbe comunque ricevere nuove richieste di deposito nel mentre. In questo modo inoltre, il <span class="blue">FridgeService</span>
può avere conferma della vera presa in carica dell'ordine dal robot. L'attesa terminerà quando il robot raggiunge la <span class="red">INDOOR</span> e carica il <b>food load</b>, in quanto
dovrà inivare la risposta di <b>chargetaken</b> al <span class="blue">FridgeService</span> che poi girerà alla <span class="blue">ServiceAccessGUI</span>.
</br>
</br>
Questa interazione può essere ulteriormente migliorata andando ad utilizzare un "trucchetto" di delegazione. Se il <span class="blue">FridgeService</span> delega la gestione del messaggio di reply
 <b>chargetaken</b> al <span class="blue">ServiceAccessGUI</span>, non ha più bisogno di aspettare esplicitamente la risposta del <span class="blue">TransportTrolley</span>, in quanto appena la risposta
 arriva, questa viene passata direttamente alla <span class="blue">ServiceAccessGUI</span> che sta comunque aspettando lo stesso tipo di risposta. Utilizzare questo metodo permette al servizio di
 non essere bloccato in attesa che il robot prenda carico della richiesta (cosiccè in futuro potrebbe essere utilizzato per altri tipi di richieste nel mentre), e permette inoltre di non complicare troppo
 il sistema con l'aggiunta di stati specifici per l'handling della risposta del trolley (come accade invece per la prima soluzione trovata).
</div>
<h3>Gestione di richieste multiple</h3>
<div class="sec remark-light">
Il sistema è già impostato per permettere l'arrivo di richieste multiple. Infatti, dopo l'arrivo di una <b>storerequest</b>, il <span class="blue">FridgeService</span> si rimette in attesa
di nuove richieste, che possono essere l'inserimento di un <b>ticket</b> ma anche una nuova <b>storerequest</b>. Il servizio tiene già traccia delle richieste aperte salvandole in una lista
(openRequestList), che permette anche la differenziazione tra le tali (associando la scadenza del biglietto e il peso del carico al numero di biglietto).
</br>
</br>
Ci sono però alcuni cambiamenti da fare alla logica del sistema per far sì che questo funzioni correttamente. Nel primo prototipo realizzato, la variabile che tiene conto della quantità
di cibo depositata nella coldroom (<b>CurrentlyStored</b>) viene aggiornata con la nuova quantità della richiesta subito dopo che il relativo <b>ticket</b> viene accettato. Questo però
può creare problemi nel caso in cui più richieste di deposito vengano inviate prima che il <span class="blue">truck driver</span> arrivi ad inserire il biglietto, perchè ogni nuova richiesta
farebbe il check della quantità depositabile con la variabile <b>CurrentlyStored</b> non ancora aggiornata con le quantità delle precedenti richieste accettate. </br> Quindi è opportuno aggiornare la variabile <b>CurrentlyStored</b> 
subito dopo che la <b>storerequest</b> viene accettata (quindi prima che il driver arrivi nella <span class="red">INDOOR</span> a caricare il biglietto). Facendo in questo modo bisogna
però tenere conto della possibilità che il <b>ticket</b> scada e quindi che la richiesta <b>sendticket</b> venga rifiutata. In questo caso si sottrae dalla variabile il carico del ticket rifiutato.
</br>
</br>
Un ultima aggiunta da fare è quella di permettere al <span class="blue">Transport Trolley</span> di prendersi in carico di un'altra richiesta subito dopo aver terminato la precedente <b>deposit action</b>.
Possiamo sfruttare le code di messaggi di cui ogni <b>actor</b> è fornito: il <span class="blue">FridgeService</span> non deve preoccuparsi del fatto che il robot stia o non stia eseguendo una deposit action
prima di inviargli una richiesta, perchè grazie al funzionamento degli <b>ActorFSM</b> se il robot è in uno stato diverso dal <b>waitingRequest</b> semplicemente inserirà ogni nuova richiesta nella sua coda dei
messaggi, per elaborarla solo dopo che avrà finito con la richiesta precedente. Più in particolare, possiamo sfruttare la direttiva <b>whenTime</b> del linguaggio <i>Qak</i> per dare tempo al
robot di verificare se ci siano nuove richieste, e in caso contrario tornarsene alla <span class="red">HOME</span>:</br>
<pre style="display:inline-block;">
<code>
Transition t0 whenTime 1000 -> moveToHome
		whenRequest takecharge -> moveToIndoor
</code>
</pre>
</div>

<h2>Progettazione</h2>
<div class="sec remark-light">
Di seguito sono mostrati i messaggi utilizzati dal sistema:
</br>
<pre style="display:inline-block;">
<code>
// ----- Messaggi per le interazioni con il basic robot -------
Request engage			: engage(OWNER,STEPTIME) //richiesta di ingaggio
Reply	engagedone		: engagedone(ARG) //risposta di conferma di ingaggio
Reply	engagerefused	: engagerefused(ARG) //risposta di rifiuto di ingaggio

Dispatch disengage		: disengage(ARG) //messaggio di disingaggio

Request moverobot		: moverobot(TARGETX, TARGETY) //richiesta di muovere il robot in una determinata posizione
Reply moverobotdone		: moverobotok(ARG) //risposta di conferma del movimento a posizione
Reply moverobotfailed	: moverobotfailed(PLANDONE, PLANTODO) //risposta di movimento a posizione non riuscita

Dispatch setrobotstate	: setpos(X,Y,D) //aggiorna la mappa con la nuova posizione e direzione
Dispatch setdirection	: dir(D) //aggiorna la posizione del robot con la nuova direzione

//--------------------------------------------------------------------

//-----------------------Messaggi applicativi------------------------
Request storerequest 	: storerequest(KG) //richiesta di depositare un food load
Reply loadaccepted		: loadaccepted(TICKET) //risposta di accettamento richiesta del load
Reply loadrefused		: loadrefused(_) //risposta di rifiuto richiesta del load

Request sendticket : sendticket(TICKET) //richiesta per inviare il ticket al servizio
Reply chargetaken : chargetaken(_) // messaggio che invia il servizio per prendere in carico una richiesta
Reply ticketrefused : ticketrefused(_) //messaggio che invia il servizio se il ticket è scaduto

Request takecharge: takecharge(TICKET) // richiesta che il servizio invia al robot per prendersi in carica di una deposit request

Dispatch tryagain: tryagain(_) // messaggio che si invia il robot per riprovare una mossa fallita

//------------------------------------------------------------------
</code>
</pre>
</br>
</div>
<h3>ServiceAccessGUI</h3>
<div class="sec remark-light">
	La <span class="blue">ServiceAccessGUI</span> è rimasta invariata rispetto allo <span class="red">SPRINT0</span>.
</div>
<h3>FridgeService</h3>
<div class="sec remark-light">
<div class="flex-container">
	  <div class="flex-child left">
		<pre>
		<code>
QActor fridgeservice context ctxcoldstorageservice{
[#
	val MAXW = 100 //max storable kg in the ColdRoom
	val TICKETTIME = 20 //seconds of ticket validity
	var CurrentlyStored : Float = 0f //kg stored in the ColdRoom	
	val openRequestList =  mutableListOf&lt;Triple&lt;Int, Float, Long&gt;?&gt;()
	var ticketValue = 0 //incrementing ticket value
#]

State so initial{
	delegate "chargetaken" to serviceaccessgui
	println("$name - START") color blue
}
Goto waitRequest

State waitRequest{
	println("$name - waiting for requests...") color blue
}
Transition t0 whenRequest storerequest -> handleRequest
				whenRequest sendticket -> handleTicket

State handleRequest{
	onMsg(storerequest: storerequest(KG)){			
		if [# payloadArg(0).toFloat() &lt; MAXW - CurrentlyStored #]{
			[# val Ticket= ticketValue
				ticketValue = ticketValue + 1
			#]
			println("$name - accepting request of ${payloadArg(0)} Kg, returning ticket: $Ticket") color blue
			replyTo storerequest with loadaccepted : loadaccepted($Ticket)	caller== serviceaccessgui
			[# CurrentlyStored += payloadArg(0).toFloat() #]
			println("$name - After the load, there will be $CurrentlyStored Kg out of $MAXW in the ColdRoom") color blue
			[# openRequestList.add(Triple(Ticket, payloadArg(0).toFloat() , System.currentTimeMillis())) #]	
		}
		else {
			println("$name - refusing request of ${payloadArg(0)} Kg (Not enough room) ") color blue
			replyTo storerequest with loadrefused : loadrefused(_)	caller== serviceaccessgui
		}	
	}
}
Goto waitRequest
		</code>
		</pre>
	  </div>
	  
	  <div class="flex-child right">
		<ul class="sep">
		<li>Nello stato <b>so</b> il servizio delega il messaggio <b>chargetaken</b> alla serviceaccessgui, in modo che non debba aspettare la risposta del trolley alla richiesta
		<b>takecharge</b>, e possa così mettersi in attesa di nuove richieste.</li>
		<li>Nello stato <b>handleRequest</b> la variabile <b>CurrentlyStored</b> viene aggiornata con il peso della nuova richiesta, a differenza di come accadeva prima che veniva fatto in <b>handleTicket</b>.</li>
		<li>Per il resto il servizio si comporta esattamente come già modellato nello SPRINT0.</li>
		</ul>
	  </div>
	</div>
	<div class="flex-container">
	  <div class="flex-child left">
		<pre>
		<code>
State handleTicket{
onMsg(sendticket: sendticket(TICKET)){
	[# 
		val Ticket = payloadArg(0).toInt()
		val request = openRequestList.find { it?.first == Ticket }			
		val elapsedTime = (System.currentTimeMillis() - request!!.third) / 1000 //elapsed time in seconds			
		val Kg = request.second //load of this request
	#] //request with the ticket value of the sendticket payload
	
	if [# elapsedTime &lt;= TICKETTIME #]{
		println("$name - accepting ticket $Ticket of request for $Kg Kg. Asking trolley to take charge") color blue
		request transporttrolley -m takecharge : takecharge($Ticket)
	}
	else{
		println("$name - refusing ticket $Ticket of request for $Kg Kg (ticket expired)") color blue
		replyTo sendticket with ticketrefused : ticketrefused(_) caller==serviceaccessgui
		[# CurrentlyStored -= Kg #] //updating currentlystored if ticket got refused
	}
	[# openRequestList.remove(request) #] //removing the request after we are done with it
}
}
Goto waitRequest
		</code>
		</pre>
	  </div>
	  
	  <div class="flex-child right">
		<ul class="sep">
		<li>Nello stato <b>handleTicket</b>, se il biglietto viene accettato il <span class="blue">FridgeService</span> invia al <span class="blue">TransportTrolley</span> la richiesta
		<b>takecharge</b> per avvisare il robot dell'arrivo di una nuova richiesta da incaricarsi.</li>
		<li>Se il biglietto viene rifiutato, la variabile <b>CurrentlyStored</b> viene aggiornata andando a togliere il peso della richiesta rifiutata.</li>
		<li>Per il resto il servizio si comporta esattamente come già modellato nello SPRINT0.</li>
		</ul>
	  </div>
	</div>
</div>
<h3>TransportTrolley</h3>
<div class="sec remark-light">
	<div class="flex-container">
	  <div class="flex-child left">
		<pre>
		<code>
QActor transporttrolley context ctxcoldstorageservice{
[# var LastAction = MoveType.MOVETOINDOOR //last action tried
   var FailedCounter = 0; //number of failed moves
#] 
State s0 initial{
	println("$name - START, engage basicrobot") color green
	request basicrobot -m engage: engage(transporttrolley,330)
}
Transition s0 whenReply engagedone -> waitRequest

State waitRequest {
	forward basicrobot -m setrobotstate : setpos(0,0,down) //just to be sure
	println("$name - waiting for a request...") color green
}
Transition t0 whenRequest takecharge -> moveToIndoor
		</code>
		</pre>
	  </div>
	  
	  <div class="flex-child right">
		<ul class="sep">
		<li>Al trolley sono state aggiunte due variabili: <b>LastAction</b> per ricordarsi dell'ultimo movimento provato ad eseguire; <b>FailedCounter</b> per ricordarsi il numero di mosse fallite.</li>
		<li>Il trolley richiede di ingaggiare il robot con uno step time di <span class="red">330</span> ms, tempo calcolato per fare in modo che il robot si sposti di una unità robotica a ogni <b>step</b> che esegue.</li>
		<li>All'inizio dello stato <b>waitRequest</b> il trolley invia al basicrobot il dispatch <b>setrobotstate : setpos(0,0,down)</b>. Questo comando serve per impostare lo stato del robot nella
		rappresentazione a griglia alla posizione 0,0 (looking down), ovvero la posizione di <span class="red">HOME</span>. Questo viene fatto solo per essere sicuri che all'avvio del servizio lo
		stato sia settato correttamente, per evitare problemi.</li>
		<li>Il trolley si sposta allo stato <b>moveToIndoor</b> quando riceve una richiesta di <b>takecharge</b>.</li>
		</ul>
	  </div>
	</div>
		<div class="flex-container">
	  <div class="flex-child left">
		<pre>
		<code>
State moveToIndoor {
	onMsg( takecharge : takecharge(TICKET) ){
		[# val Ticket="${payloadArg(0)}" #]
		println("$name - moving to INDOOR to take charge of ticket $Ticket") color green				
	}
	[# LastAction = MoveType.MOVETOINDOOR #]
	request basicrobot -m moverobot : moverobot (0,4) //(0,4) position of INDOOR in the map
						
}
Transition t0 whenReply moverobotdone -> loadTheCharge
				whenReply moverobotfailed -> failedAction

State loadTheCharge{
	println("$name - loading charge ...") color green
	delay 4000 //simulate the loading
	println("$name - taken charge of the load ...") color green
	replyTo takecharge with chargetaken: chargetaken(_) caller== fridgeservice
}
Goto moveToColdRoom

State moveToColdRoom{
	println("$name - moving to ColdRoom ...") color green
	[# LastAction = MoveType.MOVETOCR #]
	request basicrobot -m moverobot: moverobot(4,3) //(4,3) position of PORT of coldroom
}
Transition t0 whenReply moverobotdone -> storeTheCharge
					whenReply moverobotfailed -> failedAction
					
State storeTheCharge{
	println("$name - depositing load ...") color green
	delay 4000 //simulate the deposit
	println("$name - load deposited ...") color green
}
Transition t0 whenTime 1000 -> moveToHome
			whenRequest takecharge -> moveToIndoor

State moveToHome{
	println("$name - No more requests, moving to home ...") color green
	[# LastAction = MoveType.MOVETOHOME #]
	request basicrobot -m moverobot: moverobot (0,0) //(0,0) position of HOME
}
Transition t0 whenReply moverobotdone -> trolleyAtHome
					whenReply moverobotfailed -> failedAction
		</code>
		</pre>
	  </div>
	  
	  <div class="flex-child right">
		<ul class="sep">
		<li>Nello stato <b>moveToIndoor</b> il trolley aggiora la variabile <b>LastAction</b> e invia una richiesta di <b>moverobot</b> al basicRobot per spostarlo alla posizione
		(0,4), che è la posizione della <span class="red">INDOOR</span>. Se moverobot ha successo il trolley si sposta allo stato <b>loadTheCharge</b>, altrimenti va allo stato
		<b>failedAction</b>.</li>
		<li>Nello stato <b>loadTheCharge</b> il trolley carica il load e invia la risposta <b>chargetaken</b>, per informare la ServiceAccessGUI che il load è stato preso in carico.</li>
		<li>Nello stato <b>moveToColdRoom</b> il trolley aggiora la variabile <b>LastAction</b> e invia una richiesta di <b>moverobot</b> al basicRobot per spostarlo alla posizione
		(4,3), che è la posizione della <span class="red">PORT</span> della <b>coldroom</b>. Se moverobot ha successo il trolley si sposta allo stato <b>storeTheCharge</b>, altrimenti va allo stato
		<b>failedAction</b>.</li>
		<li>Nello stato <b>storeTheCharge</b> il trolley deposita il carico nella coldRoom. Se ci sono nuove richieste da prendersi in carico, ci si sposta allo stato <b>moveToIndoor</b> per ripetere
		le operazioni mostrate sopra. Se invece dopo un secondo non sono arrivate nuove richieste di deposito, il trolley si sposta allo stato <b>moveToHome</b></li>
		<li>Nello stato <b>moveToHome</b> il trolley aggiora la variabile <b>LastAction</b> e invia una richiesta di <b>moverobot</b> al basicRobot per spostarlo alla posizione
		(0,0), che è la posizione della <span class="red">HOME</span>. Se moverobot ha successo il trolley si sposta allo stato <b>trolleyAtHome</b>, altrimenti va allo stato
		<b>failedAction</b>.</li>
		</ul>
	  </div>
	</div>
	<div class="flex-container">
	  <div class="flex-child left">
		<pre>
		<code>
State trolleyAtHome{
	println("$name - trolleyAtHome ... ") color green
	forward basicrobot -m setdirection : dir(down)
	delay 1000 //To avoid interrupt of plan related to setDirection		
}
Goto exitSystem

State failedAction{
	[# FailedCounter += 1 #]
	println("$name - The last action (${LastAction.name}) failed, trying again") color green
	forward transporttrolley -m tryagain : tryagain(_)
}
Transition t0
	whenMsg tryagain and [# FailedCounter >= 10 #] -> exitSystem
	whenMsg tryagain and [# LastAction == MoveType.MOVETOINDOOR #] -> moveToIndoor
	whenMsg tryagain and [# LastAction == MoveType.MOVETOCR #] -> moveToColdRoom
	whenMsg tryagain and [# LastAction == MoveType.MOVETOHOME #] -> moveToHome


State exitSystem {
	onMsg( tryagain : tryagain(_)){
		println("$name - Too many fails, exiting the system") color green
	}
	forward basicrobot -m disengage : disengage(transporttrolley)
	println("$name - disengaged") color green
	delay 1000 //avoid to premature abort of connection
	[# System.exit(0) #]
}
		</code>
		</pre>
	  </div>
	  
	  <div class="flex-child right">
		<ul class="sep">
		<li>Nello stato <B>trolleyAthome</B> il trolley invia al robot un comando di <b>setdirection</b> per ruotare il suo orientamento a <span class="red">down</span>.</li>
		<li>Nello stato <b>exitSystem</b> si disingaggia il robot attraverso il dispatch <b>disengage</b> e si esce dal sistema.</li>
		<li>Nello stato <b>failedAction</b> si incrementa il valore della varaibile <b>FailedCounter</b> e si torna allo stato che ha causato il problema, facendo uso delle guardie di
		transizione. Se ci sono state troppe failedMoves si passa invece allo stato <b>exitSystem</b> per uscire dal sistema.</li>
		</ul>
	  </div>
	</div>
</div>


<h3>Architettura logica del sistema</h3>
Il prototipo realizzato in questo sprint può essere riassunto nella seguente architettuta:
<blockquote>
<a class="reference internal image-reference" href="./immagini/ArchitetturaLogicaSprint1.png"><img alt="./immagini/ArchitetturaLogicaSprint1.png" class="align-center" src="./immagini/ArchitetturaLogicaSprint1.png" style="width: 30%;" /></a>
</blockquote>
<h2>Piani di testing</h2>
Per effettuare i test si è realizzata una variante del modello (<a href="Sprint1Model/src/Sprint1ModelTest.qak">Sprint1ModelTest.qak</a>)in cui l'unica differenza è che la <span class="blue">ServiceAccessGUI</span> non invia nessun messaggio in maniera automatica (non simula l'interazione con il driver), in modo che possiamo
usare un test class per inviare e ricevere messaggi.
<div class="sec remark-light">
<span class="remark"> L'osservibilità CoaP</span></br></br>
Al fine di realizzare dei test più completi è opportuno introdurre una proprietà degli <b>Actors Qak</b>: Ogni attore del sistema è una risporsa <span class="red">COAP</span> osservabile.
Questo significa che un alieno esterno al sistema (come la nostra test class) può diventare un <b>observer coap</b> di un attore del sistema, se conosce l'host address, la porta e il nome dell'attore
e del contesto in cui è implementato (se invece un attore vuole osservare un altro attore può semplicemente usare la direttiva qak <b>observeResource</b>). Un attore può
 inviare aggiornamenti alle risorse che lo stanno osservando tramite la direttiva <b>updateResource</b> (si veda <a href="../html/AppuntiTecnologie.html#coap">CoaP</a>, <a href="../html/Actors23Coap.html">Actors23Coap</a> e <a href="../html/QakActors23.html">QakActors23</a> per ulteriori informazioni).
</br>
</br>
Tramite l'osservabilità COAP è possibile far mandare dai componenti del sistema un <b>updateResource</b> per ogni operazione che si svolge o ogni stato in cui si entra, in modo tale che
una <b>test application</b> possa ottenere informazioni dal sistema e fare vari check per verificare che un'azione si sia svolta correttamente.
</br> 
In particolare, ogni <span class="blue">test class</span> avrà la seguente struttura:
	<div class="flex-container">
	  <div class="flex-child left">
		<pre>
		<code>
class TestClass : CoapHandler {
    lateinit var client : CoapClient
    lateinit var obsRel : CoapObserveRelation
    val host : String = "localhost"
    val port : Int = 9990
    val path : String = "ctxcoldstorageservice/actorToObserve"

    val contentList = mutableListOf<String>() //list of the content received by the observable resource


    override fun onLoad(response: CoapResponse?) {
        var content: String? = response?.responseText
        var payload = getPayloadArgs(content)[0]
        contentList.add(payload)
    }

    override fun onError() {
        println("TestClass - ERROR")
    }

    fun createObserver(host: String, port: Int, path: String){
        val url = host + ":" + port + "/" + path
        client = CoapClient("coap://" + url)
        obsRel = client.observe(this)
    }

    companion object {
        @BeforeClass
        @JvmStatic
        fun setup() {
            it.unibo.ctxcoldstorageservice.main()
            CommUtils.delay(5000)

        }
    }

    @Before
    fun initTest() {
        createObserver(host, port, path)
    }
		</code>
		</pre>
	  </div>
	  
	  <div class="flex-child right">
		<ul class="sep">
		<li>La classe implementa l'interfaccia <b>CoapHandler</b> che definisce due metodi: <b>OnLoad()</b> che viene chiamato quando un attore osservato effettua una updateResource e
		inserisce il payload del messaggio arrivato all'interno di una lista <b>contentList</b>, per tenere traccia dei messaggi arrivati; <b>OnError</b> in caso di errore.</li>
		<li>Il metodo <b>createObserver</b> crea il <span class="blue">CoapClient</span> che osserverà la risorsa CoaP posta all'indirizzo <b>host</b>, porta <b>port</b>, e path <b>path</b> ("ctx/actor").</li>
		</ul>
	  </div>
	</div>
</div>
</br>
Al fine di testare il corretto funzionamento del sistema, sono stati introdotti i seguenti <b>piani di testing</b>, che vanno ad aggiungersi ai due test <span class="red">TestColdRoomFull</span>
 e <span class="red">TestTicketRefused</span> creati nello SPRINT0 e che sono ancora validi per questo sprint:
<div class="sec remark-light">
<ul class="sep">
<li><span class="remark">TestRequestAcceptedFull</span>: Test del normale funzionamento del sistema. Si invia una richiesta che non sfori il limite massimo della <b>coldRoom</b> e si verifica che il ticket venga accettato e che
il trolley ritorni correttamente nella home al termine dell'azione di deposito.</li>
</ul>
<div class="flex-container">
  <div class="flex-child left">
	<pre>
	<code>
@Test
fun testRequestAccepted() {
	val conn: Interaction = ConnectionFactory.createClientSupport23(
		ProtocolType.tcp, "localhost", "9990")

	println("TestApplication - Sending store request of 30 kg")
	val storeRequest: IApplMessage = CommUtils.buildRequest("testApplication", "storerequest", "storerequest(30)", "fridgeservice")
	val storeReply: IApplMessage? = conn.request(storeRequest)
	val ticket: String = getPayloadArgs(storeReply?.msgContent())[0]

	//If everything goes as it should, the reply to the storerequest will be loadaccepted
	Assert.assertEquals("loadaccepted", storeReply?.msgId())

	println("TestApplication - Simulating going to indoor to send ticket")
	CommUtils.delay(4000)
	conn.forward("msg(sendticket,request,testApplication,fridgeservice,sendticket("+ticket+"),1)")

	//wait for the "at home" response of the robot
	var limit = 0
	while ( "at home" !in contentList AND limit &lt; 15){
		limit += 1
		CommUtils.delay(2000)
	}

	//if everything goes as it should, the robot must reach home when it finishes
	assertTrue("at home" in contentList)
}
	</code>
	</pre>
  </div>
  
  <div class="flex-child right">
	<ul class="sep">
	<li>All'inizo del test si crea una connessione TCP con il contesto del <span class="blue">ColdStorageService</span>.</li>
	<li>Poi si crea e invia la richiesta <b>storeRequest</b> per un carico di 30kg, e si attende la risposta del sistema con il <b>ticket</b> da inserire. Poi si fa il check della risposta,
	che dovrebbe essere <b>loadaccepted</b>.</li>
	<li>In seguito si aspetta una quantità di tempo (minore del tempo massimo per inserire un biglietto) per simulare l'arrivo nella <span class="red">INDOOR</span> e si invia una nuova richiesta <b>sendticket</b> al sistema.</li>
	<li>Infine si attende in un ciclo while che la test application riceva il messaggio <b>"at home"</b>, che viene inviato dal <span class="blue">TransportTrolley</span> quando tutte le richieste
	sono state eseguite e il trolley è tornato nella <span class="red">HOME</span>. Quindi se entro un certo tempo massimo questo messaggio arriva, significa che l'azione di deposito si è
	 conclusa correttamente.</li>
	</ul>
  </div>
</div>

</div>
<div class="sec remark-light">
<ul class="sep">
<li><span class="remark">TestMultipleRequest</span>: Si testa il funzionamento del sistema nel caso arrivino più richieste in successione. In particolare, si testa l'invio di 3
richieste in successione rapida (prima che il trolley riesca ad elaborare la precedente), di cui l'ultima sfora il limite massimo di peso nella <b>ColdRoom</b>, per verificare
se il <span class="blue">FridgeService</span> riesce a processare più richieste insieme e se il <span class="blue">TransportTrolley</span> prende in carico una nuova richiesta
dopo averne conclusa una precedente.</li>
</ul>
<div class="flex-container">
  <div class="flex-child left">
	<pre>
	<code>
@Test
fun testRequestAccepted() {
	val conn: Interaction = ConnectionFactory.createClientSupport23(
		ProtocolType.tcp, "localhost", "9990")

	//first request
	println("TestApplication - Sending first store request of 30 kg")
	val storeRequest1: IApplMessage = CommUtils.buildRequest("testApplication", "storerequest", "storerequest(30)", "fridgeservice")
	val storeReply1: IApplMessage? = conn.request(storeRequest1)
	val ticket1: String = getPayloadArgs(storeReply1?.msgContent())[0]

	//If everything goes as it should, the reply to the storerequest will be loadaccepted
	Assert.assertEquals("loadaccepted", storeReply1?.msgId())

	//second request
	println("TestApplication - Sending second store request of 50 kg")
	val storeRequest2: IApplMessage = CommUtils.buildRequest("testApplication", "storerequest", "storerequest(50)", "fridgeservice")
	val storeReply2: IApplMessage? = conn.request(storeRequest2)
	val ticket2: String = getPayloadArgs(storeReply2?.msgContent())[0]

	//If everything goes as it should, the reply to the storerequest will be loadaccepted
	Assert.assertEquals("loadaccepted", storeReply2?.msgId())

	//third request
	println("TestApplication - Sending third store request of 40 kg")
	val storeRequest3: IApplMessage = CommUtils.buildRequest("testApplication", "storerequest", "storerequest(40)", "fridgeservice")
	val storeReply3: IApplMessage? = conn.request(storeRequest3)

	//If the coldroom can't fit the third load, it has to return loadrefused
	Assert.assertEquals("loadrefused", storeReply3?.msgId())

	//sending first ticket
	CommUtils.delay(4000)
	println("TestApplication - Inserting first ticket")
	conn.forward("msg(sendticket,request,testApplication,fridgeservice,sendticket("+ticket1+"),1)")

	//sending second ticket
	CommUtils.delay(3000)
	println("TestApplication - Inserting second ticket")
	conn.forward("msg(sendticket,request,testApplication,fridgeservice,sendticket("+ticket2+"),1)")

	//wait for the "at home" response of the robot
	var limit = 0
	while ( "at home" !in contentList AND limit &lt; 35){
		limit += 1
		CommUtils.delay(4000)
	}

	//if everything goes as it should, the robot must reach home when it finishes
	Assert.assertTrue("at home" in contentList)

	//if everything goes as it should, the contentlist should containt 2 times the charge taken message
	var count = contentList.count { it.contains("charge taken") }
	Assert.assertEquals(2, count)
}
	</code>
	</pre>
  </div>
  
  <div class="flex-child right">
	<ul class="sep">
	<li>All'inizo del test si crea una connessione TCP con il contesto del <span class="blue">ColdStorageService</span>.</li>
	<li>Poi si crea e invia una prima richiesta <b>storeRequest</b> per un carico di 30kg, e si attende la risposta del sistema con il <b>ticket</b> da inserire. Poi si fa il check della risposta,
	che dovrebbe essere <b>loadaccepted</b>.</li>
	<li>Si effettua poi una seconda richiesta di 50kg seguendo lo stesso procedimento della prima.</li>
	<li>Si effettua poi una terza richiesta di 40kg. Questa richiesta sforerebbe il limite della <b>ColdRoom</b>: 30kg + 50kg + 40kg &gt; 100Kg. Quindi se il sistema funziona
	correttamente la risposta dovrà essere <b>loadRefused</b>.</li>
	<li>In seguito si aspetta una quantità di tempo (minore del tempo massimo per inserire un biglietto) per simulare l'arrivo nella <span class="red">INDOOR</span> e si invia una nuova richiesta <b>sendticket</b> al sistema,
	con il primo ticket ricevuto come payload. Si fa poi la stessa cosa per il secondo ticket ricevuto.</li>
	<li>Infine si attende in un ciclo while che la test application riceva il messaggio <b>"at home"</b>, che viene inviato dal <span class="blue">TransportTrolley</span> quando tutte le richieste
	sono state eseguite e il trolley è tornato nella <span class="red">HOME</span>. Quindi se entro un certo tempo massimo questo messaggio arriva, significa che le azioni di deposito si sono
	 concluse correttamente.</li> 
	<li>Per essere però sicuri che il <span class="blue">TransportTrolley</span> abbia effettivamente preso in carico tutte le richieste e non solo una si va a contare il numero delle volte
	 che il messaggio <b>"charge taken"</b> (che invia con un <b>updateResource</b> dopo aver preso un carico) è presente nella <b>contentList</b>. Se il messaggio è presente due volte significa
	 che tutte e due le richieste sono state prese in carico.</li>
	</ul>
  </div>
</div>

</div>


<h2>Piano di lavoro</h2>
Nello <span class="red">SPRINT2</span> si estenderà il sistema prodotto nello SPRINT1 realizzando la fase reattiva del robot, andando a realizzare il componente distribuito <span class="blue">AlarmDevice</span>,
che interagisce col robot tramite messaggi di <b>stop/resume</b>, e modellando anche le azioni del <i>warning device</i> .


</div>
</body>
</html>
 
<!-- USEFUL
<table style="width:100%" border="1">
<tr>
<td style="width:50%">
</td>
<td></td>
</tr>
</table>
-->
	      	
<br/><br/> 	
</div>  

<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">
By Matteo Giri email: matteo.giri@studio.unibo.it
<br>
Link GitHub Repo: https://github.com/s1090263/iss2023/
<img src="../Sprint0/immagini/fotoGiriMatteo.jpg" alt="foto" width="20%" height="20%">
</div> 
</body>
</html>