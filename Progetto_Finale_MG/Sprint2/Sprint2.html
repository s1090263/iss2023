<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<link rel="stylesheet" href="html/prism.css">
<script src="html/prism.js"></script>
<style type="text/css">
body
{
    margin-left:  10px;
    margin-right: 10px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
	font-size: 93%;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
	border-radius: 10px;
	padding: 5px;
}

top {
	width: 100%;
}


#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 90%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #abe876;
    color: #1632cc;
}
bc{
	font-family: "Arial";
	font-size: 90%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	font-size: 90%;
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	font-size: 90%;
}
pre{
	font-family: "Consolas";
	font-size: 85%;
	background-color: #f5f5f5;
	border: 1.5px solid silver;
	padding: 5px;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
	 
    font-size: 18px;
}
k{
    color: #990000;
	font-weight: bold;
	font-size: 90%;
}
h1 {
    font-size: 150%;
    background-color: #b2c0ff;
	padding: 10px;
}

h2 {
    background-color: #9ed8ff;
    font-size: 130%;
}

h3 {
	background-color: #e6ccff;
    font-size: 100%;
}
h4 {
    background-color: #ccffcc;
    font-size: 100%;
	width: 95%;
	border-radius: 5px;
	padding: 2px;
}
h5 {
    background-color: #d5ffb0;
    font-size: 100%;

}
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}
div.remark{
	background-color: #E3F2FD;
    border: 1.5px solid #d5f2ed;
    padding: 15px;
    margin: 10px;
	border-radius: 25px;
}
div.remark-light{
	background-color: #F0FFFF;
    border: 1.5px solid #d5f2ed;
    padding: 15px;
    margin: 10px;
	border-radius: 15px;
}
span.remark{
	background-color: #6b9cff;
    border: 1.5px solid #d5f2ed;
    padding: 1px;
    margin: 5px;
	border-radius: 25px;
	font-size: 120%;
}

table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}

ol, ul, li {
  margin: 0;
  margin-left: 10px;
  padding: 0;
  padding-bottom: 0px;
}

table, th, td {
	border: 1px solid black;
}

img {
	border: 1.5px solid #d5f2ed

}

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

div.wrapdesc{
	width: 90%;
	margin: auto;
}

div.imagedesc{
	width: 85%;
	margin: auto;
}
.blue{
    color: blue;
}
.red{
	color: red;
}
.sep li{
	padding-bottom: 10px;
}
div.sec{
margin-top: 10px;
margin-left: 30px;
margin-right: 30px;
}
.align-center{
	display: block;
	margin-left: auto;
	margin-right: auto;
}
pre.language-java {
      max-width: 800px; /* Adjust the max-width as needed */
      overflow-x: auto;
      display: inline-block; 
	  padding-top: 0em;
	  padding-bottom: 0em;
	  margin-left: 100px;
    }
	
pre{
overflow: auto;
}

.flex-container {
    display: flex;
}

.flex-child {
	width: 50%;
	flex:1;
}  

.flex-child.left {
    margin-right: 20px;
	overflow: hidden;
	 flex-shrink: 0;
}

.flex-child.right {
	padding-top: 20px;
	 flex-shrink: 1;
}

.small{
font-size:65%;
}

.inline{
display: inline-block;
padding: 0px;
}
</style>
    
<head>
   
<title>Sprint2 Giri Matteo</title>

</head>
    
<body>
<div id="top">
<h1>TEMA FINALE SPRINT2<font size="5"></font> </h1>
</div>

<span class="blue"></span> 
<span class="red"><b></b></span> 

<div class="body"> 
<h2>Introduzione</h2>
Nello <a href="../Sprint1/Sprint1.html"><span class="red">SPRINT1</span></a> abbiamo affrontato la creazione del <span class="blue"><b>core applicativo</b></span> del sistema, andando a realizzare
un prototipo eseguibile con la seguente architettura:

<blockquote>
<a class="reference internal image-reference" href="../Sprint1/immagini/ArchitetturaLogicaSprint1.png"><img alt="../Sprint1/immagini/ArchitetturaLogicaSprint1.png" class="align-center" src="../Sprint1/immagini/ArchitetturaLogicaSprint1.png" style="width: 30%;" /></a>
</blockquote>


In questo sprint andrò ad affrontare il problema della realizzazione degli <span class="blue"><b>alarm requirements</b></span>.
<h2>Requisiti</h2>
Nello <span class="red">SPRINT2</span> ci concentriamo solo sui seguenti requisiti:
<div class="sec remark">
<p>The system includes a a <span class="blue">Sonar</span> and a <span class="blue">Led</span> connected to a RaspnerryPi.</p>
<p>The <span class="blue">Sonar</span> is used as an ‘alarm device’: when it measures a distance less that a prefixed value <strong>DLIMT</strong>,
the <span class="blue">transport trolley</span> must be stopped; it will be resumed when <cite>Sonar</cite> detects again a distance higher
than  <strong>DLIMT</strong>.</p>
<p>The <cite>Led</cite> is used as a <cite>warning devices</cite>, according to the following scheme:</p>
<blockquote>
<div><ul class="simple">
<li><p>the <cite>Led</cite> is <strong>off</strong> when the  <cite>transport trolley</cite> is at <cite>HOME</cite></p></li>
<li><p>the <cite>Led</cite> <strong>blinks</strong> while the <cite>transport trolley</cite> is moving</p></li>
<li><p>the <cite>Led</cite> is <strong>on</strong> when <cite>transport trolley</cite> is stopped.</p></li>
</ul>
</div>
</div>
In questa fase ci interessa solo la seguente user story:
<div class="sec remark">
<i>While the <span class="blue">transport trolley</span> is moving, the <b>Alarm requirements</b> should be satisfied.
However, the <span class="blue">transport trolley</span> should not be stopped if some prefixed amount
of time (<strong>MINT</strong> msecs) is not passed from the previous stop.</i>
</div>

<h2>Analisi del problema</h2>
<div class="sec remark-light">
	<span class="remark">KeyPoints - Analisi del problema</span>
	</br>
	</br>
	<ul class="sep">
	<li>Si realizzano due nuovi componenti del sistema come <b>actor</b> in un contesto distribuito: l'<span class="blue">AlarmDevice</span> e il <span class="blue">WarningDevice</span>.</li>
	<li>L'<span class="blue">AlarmDevice</span> ha il compito di inviare i dispatch di <b>stoptrolley</b> e <b>resumetrolley</b> al <span class="blue">ColdStorageService</span>, in base alle informazioni
	di distanza ricevute da una pipeline di <b>StreamedQActors</b> che filtrano i dati ricevuti da un <b>sonar</b> fisico o simulato.</li>
	<li>Il <span class="blue">WarningDevice</span> utilizza l'<b>osservabilità CoaP</b> degli attori per ricevere informazioni sullo stato del <span class="blue">TransportTrolley</span> in modo
	da poter accendere o spegnere un <b>Led</b> fisico o simularlo.</li>
	<li>E' il <span class="blue">FridgeService</span> effettivamente ad inviare dispatch di <b>stoptrolley</b> e <b>resumetrolley</b> al <span class="blue">TransportTrolley</span>, e ad
	emettere un evento <b>alarm</b> per fermare il movimento del <span class="blue">BasicRobot</span>. </li>
	<li>Si introduce lo stato di <b>stop</b> in cui il <span class="blue">TransportTrolley</span> attende un messaggio di <b>resumetrolley</b> per tornare ad eseguire le azioni che stava
	eseguendo prima di essere stoppato.</li>
	</ul>
</div>

<h3>Come costruire l'Alarm Device</h3>
<div class="sec remark-light">
L' <span class="blue">Alarm Device</span> è un'entita che lavora in maniera distribuita in un RaspberryPi che utilizza dispositivi fisici quali <i>Led</i> e <i>Sonar</i>.
L'entità dovrà comunicare con i componenti del sistema già realizzati per permettere di stoppare e riavviare il trolley. Viene quindi naturale continuare con l'ideologia degli <b>Attori</b>
e realizzare il componente come un sistema ad attori che lavora in un contesto differente da quello del <span class="blue">ColdStorageService</span> ma che può comunicarci attraverso
scambio di messaggi. </br>
Il committente fornisce del software utile allo sviluppo di questo tipo di sistema. In particolare, il progetto <b>unibo.sonarqak23</b> fornisce un esempio di base di realizzazione di un sistema
ad attori che cattura dati emessi da un dispositivo <a href="../html/RaspApplCode.html#sonar-e-led-come-attori">SONAR HC-SR04</a> e li passa attraverso una <b>pipeline di filtraggio</b>
per ottenere poi informazioni utili da poter utilizzare nella logica applicativa del sistema (si veda  <a href="../html/RaspApplCode.html">RaspApplCode.html</a> per ulteriori informazioni).
</br>
L'architettura del sistema di allarme può essere riassunta in questo modo:

<blockquote>
<a class="reference internal image-reference" href="immagini/ArchitetturaAlarmDevice.png"><img alt="immagini/ArchitetturaAlarmDevice.png" class="align-center" src="immagini/ArchitetturaAlarmDevice.png" style="height: 20%;" /></a>
</blockquote>

L'attore <span class="blue">Sonar</span> è il componente che raccoglie i dati dal sonar fisico. E' rappresentabile da due tipi di <b>CodedQActor</b>: <a href="#sonarsimulator"><b>sonarSimulator</b></a>, che viene usato per
testare l'applicazione in locale e simula la ricezione dei dati dal sonar andando a crearne di sintetici; <a href="#sonarhcsr"><b>sonarHCSR04Support23.kt</b></a> che viene usato nel raspberry e riceve dati dal sonar fisico con cui comunica tramite il programma python <a href="#sonarpy"><b>sonar.py</b></a>. <span class="blue">Sonar</span>  invia i dati al sistema tramite la direttiva <b>emitLocalStreamEvent( event )</b>, che permette 
di emettere un evento propagato solo agli attori locali che siano ‘registrati’ presso di lui (come ad esempio dataCleaner) mediante il metodo <b>subscribeToLocalActor</b>.
</br></br>
L'attore <a href="#datacleaner"><span class="blue">datacleaner</span></a> è anch'esso un <b>CodedQactor</b> e filtra i dati ricevuti da <span class="blue">Sonar</span> (in quanto ci si iscrive con <b>subscribeToLocalActor</b>),
andando ad eliminare valori troppo alti o bassi che possono essere considerati come rumore, e emettendo come eventi locali quelli che rimangono.
</br></br>
L'attore <a href="#distancefilter"><span class="blue">distancefilter</span></a> è anch'esso un <b>CodedQactor</b> e filtra i dati ricevuti da <span class="blue">datacleaner</span> (in quanto ci si iscrive con <b>subscribeToLocalActor</b>).
L'attore emette un evento locale <b>obstacole</b> se la distanza che gli è arrivata è minore di <span class="red">DLIMT</span>, mentre emette l'evento locale <b>free</b> in caso contrario.
</br></br>
Infine, l'attore <a href="#alarmdevice"><span class="blue">AlarmDevice</span></a> gestisce la logica di sistema. Crea la pipeline (secondo la logica degli <a href="../html/QakActors23.html#streamedqactor">StreamedQActors</a>) tramite sottoscrizione:
</br><pre class="inline"><code>subscribeToLocalActor("distancefilter").subscribeToLocalActor("datacleaner").subscribeToLocalActor("sonar")</code></pre></br>
AlarmDevice decide se inviare un messaggio di stop o un messaggio di resume a chi di dovere (si veda "Chi stoppa il Transport Trolley ?") in base all'evento ricevuto dalla pipeline (<b>free</b> o <b>obstacle</b>).
</div>

<h3>Come costruire il Warning Device</h3>
<div class="sec remark-light">
Un'altro requisito degli Alarm Requirements è quello del <span class="blue">WarningDevice</span>. Anche questo componente può essere modellato come un attore nel contesto dell'alarmDevice. 
Il <a href="#warningdevice"><span class="blue">WarningDevice</span></a> sfrutta l'<b>osservabilità CoaP</b> degli attori per andare ad osservare il sistema <span class="blue">ColdStorageService</span>:
quando un attore del sistema effettua una <b>updateResource</b> il WarningDevice riceverà un messaggio
</br><pre class="inline"><code>Dispatch coapUpdate: coapUpdate(RESOURCE, VALUE)</code></pre></br>
In base alla natura del messaggio inviato, il WarningDevice aggiornerà lo stato di un Led fisico, facendo uso di semplici programmi python che comunicano con il led:
<a href="#ledblinkpy"><b>LedBlink.py</b></a>, <a href="#ledonpy"><b>LedOn.py</b></a>, <a href="#ledoffpy"><b>LedOff.py</b></a>. 
</br>
</br>
Per poter rendere il dispositivo utilizzabile anche in un sistema di testing locale, oltre ad attivare i programmi python per comunicare col led fisico effettua anche una <b>UpdateResource</b>
per informare chi è in ascolto dello stato del led: <b>warningdevice(on)</b>, <b>warningdevice(blink)</b>, <b>warningdevice(off)</b>.
</br>
</br>
Dopo l'aggiunta del <span class="blue">WarningDevice</span> l'architettura del sistema su raspberry diventa quindi:

<blockquote>
<a class="reference internal image-reference" href="immagini/ArchitetturaAlarmDevice2.png"><img alt="immagini/ArchitetturaAlarmDevice2.png" class="align-center" src="immagini/ArchitetturaAlarmDevice2.png" style="height: 20%;" /></a>
</blockquote>
</div>


<h3>Chi stoppa il Transport Trolley ?</h3>
<div class="sec remark-light">
I requisiti non esplicitano l'entita che debba stoppare (o riattivare) il <span class="blue">Transport Trolley</span>. E' quindi
doveroso chiarire questo dubbio per capire come è meglio procedere.
</br>
Con <b>stoppare</b> il Trolley si intende fermare il suo movimento o comunque bloccarlo nello stato corrente (per esempio se sta scaricando il carico non vogliamo che vada nello stato di movimento per bloccarlo).
Questo significa che ci sono due situazioni in cui il trolley può essere stoppato: mentre si sta muovendo; mentre sta eseguendo un azione di carico, scarico, o waiting di richieste.

Per quanto riguarda il movimento, il messaggio di <b>stop</b> deve essere inviato direttamente al <span class="blue">BasicRobot</span>, in quanto il <span class="blue">Trolley</span>
vede l'intera operazione di movimento come se fosse atomica, non stoppabile. Fortunatamente il <span class="blue">BasicRobot</span> divide il movimento richiesto con <b>moverobot</b> in
operazioni elementari (<b>steps</b>), ed è provvisto di un evento chiamato </br><pre class="inline"><code>Event alarm : alarm(X)</code></pre></br> che se emesso blocca il robot dopo l'ultimo
step percorso, ritornando una risposta di <b>moverobotfailed</b> al Trolley che ne ha richiesto il movimento.</br>
Per quanto riguarda invece lo stop in uno stato, dovrà essere il <span class="blue">Transport Trolley</span> ad essere informato per fermarsi nello stato corrente.
</br>
</br>
 L'<span class="blue">Alarm Device</span> è un'entità posta in un contesto esterno al <span class="blue">ColdStorageService</span>, in 
quanto stiamo parlando di un sistema distribuito in cui l'entità deve lavorare con <i>Sonar</i> e <i>Led</i> connessi a un RaspberryPi. Quindi non è opportuno far stoppare
direttamente il trolley e il robot da questa entità, perchè dovrebbe inviare messaggi diversi (al robot e trolley) e il sistema (<span class="blue">FridgeService</span>) non sarebbe informato
direttamente dello stop in corso. Una soluzione migliore è quella di far inviare dei messaggi di stop e resume dall'<span class="blue">AlarmDevice</span> al <span class="blue">FridgeService</span>:
</br><pre class="inline"><code>Dispatch stoptrolley : stoptrolley(ARG)
Dispatch resumetrolley : resumetrolley(ARG)</code></pre></br>
Sarà poi compito del <span class="blue">FridgeService</span> andare a stoppare e riattivare il <span class="blue">BasicRobot</span> e il <span class="blue">Trolley</span>, utlizzando gli
stessi dispatch che invia l'AlarmDevice e l'evento <b>alarm</b>.
</div>

<h3>Cambiamenti al ColdStorageService</h3>

<div class="sec remark-light">
Ci sono alcuni problemi da affrontare per permettere il corretto funzionamento delle nuove funzionalità nel sistema del <span class="blue">ColdStorageService</span>.
</br>
</br>
Una prima considerazione da fare è che anche se i messaggi di stop e resume devono passare per il <span class="blue">FridgeService</span>, questo non è un problema in quanto per
come ho realizzato il sistema il servizio non è mai bloccato in attesa di risposte. Può quindi ricevere ed elaborare gli evenutali messaggi che arrivano dall'<span class="blue">AlarmDevice</span> senza
intoppi (anche se prima del messaggio di stop dovessero arrivare molte richieste di deposito al sistema, queste verrebbero comunque gestite molto velocemente e quindi lo stop non deve attendere di essere eseguito).
</br>
</br>
E' importante che il <span class="blue">FridgeService</span> invii il messaggio di <b>stop</b> al <span class="blue">Transport Trolley</span> prima di emettere l'evento <b>alarm</b>. Questo
viene fatto perchè in caso contrario il robot potrebbe stopparsi prima del Trolley e inviare la risposta di <b>moverobotfailed</b> che porterebbe il trolley nello stato di <b>failedAction</b> (che serve
per riprovare la mossa non eseguita correttamente), e non è ciò che vogliamo. Se inviamo prima lo stop il Trolley andrà in uno stato di <b>stop</b> dove attenderà di essere riattivato.
</br>
</br>
La classe enum <span class="red">MoveType</span> deve essere arricchita con nuovi termini, ognuno riguardate l'ultimo stato in cui si è trovato il Trolley:
</br>
<pre style="display:inline-block;">
<code>
enum class MoveType {
    MOVETOINDOOR,
    MOVETOCR,
    MOVETOHOME,
	WAITREQUEST,
	LOADCHARGE,
	STORECHARGE
}
</code>
</pre>
</br>

Questa aggiunta è necessaria perchè quando il Trolley viene bloccato passerà allo stato di <b>stop</b> dove attende di essere riattivato. Quando viene riattivato deve sapere in
che stato era stato bloccato per poterci tornare.
</br>
</br>
Nelle transizioni di ogni stato il <span class="blue">Transport Trolley</span> deve includere quella relativa al messaggio di <b>stoptrolley</b>, che lo porta allo stato di <b>stop</b>
</br>
</br>
Si deve introdurre una nuova variabile del Trolley chiamata <code>var stopped : Boolean</code> che è <i>true</i> se il trolley è stato stoppato. Questa variabile permette di non
rieseguire tutte le azioni dello stato in cui è stato stoppato, in quanto se <b>stopped</b> è <i>true</i>, verrà semplicemente messa a <i>false</i> al posto di eseguire le operazioni già
eseguite. E' stata introdotta soprattutto per permettere al <span class="blue">Transport Trolley</span> di verificare se ci siano nuove richieste da prendere in carico quando viene stoppato subito
dopo aver depositato il carico precedente.
</br>
Questo meccanismo non provoca effetti collaterali negativi nel far ripartire il <span class="blue">BasicRobot</span> in caso si stesse muovendo prima dello <b>stop</b>. Infatti, quando il trolley viene riattivato
andrà nello stato di movimento corrispondente (senza rieseguire tutte le operazioni), ed avendo ricevuto un messaggio <b>moverobotfailed</b> si sposterà allo stato <b>failedAction</b> che
farà ritentare il movimento fallito al Robot (Quindi riattivare il <span class="blue">Transport Trolley</span> riattiva in maniera implicita anche il <span class="blue">BasicRobot</span>).
</div>
<h3>Architettura logica</h3>
<div class="sec remark-light">
L'architettura logica finale ricavata nello <span class="red">SPRINT2</span> è mostrata nella seguente figura:

<blockquote>
<a class="reference internal image-reference" href="immagini/ArchitetturaLogicaSprint2.png"><img alt="immagini/ArchitetturaLogicaSprint2.png" class="align-center" src="immagini/ArchitetturaLogicaSprint2.png" style="width: 40%;" /></a>
</blockquote>

</div>
<h2>Progettazione - AlarmDevice</h2>
<div class="sec remark-light">
I messaggi scambiati dal sistema di alarm sono i seguenti:
</br>
<pre style="display:inline-block;">
<code>
//-------------------------Messaggi---------------------------------
Event obstacle  : obstacle(D)   //emitted as stream by distancefilter
Event free		: free(D)       //emitted as stream by distancefilter

Dispatch stoptrolley : stoptrolley(ARG) //message sent to fridgeservice to stop trolley
Dispatch resumetrolley : resumetrolley(ARG) //message sent to fridgeservice to resume trolley
Dispatch coapUpdate: coapUpdate(RESOURCE, VALUE)
//------------------------------------------------------------------
</code>
</pre>
</br>
</div>
<h3 id="sonarsimulator">SonarSimulator.kt</h3>
Classe che simula la ricezione di dati da un sonar e li trasmette alla pipeline.
<div class="sec remark-light">
<div class="flex-container">
	  <div class="flex-child left">
		<pre>
		<code>
class sonarSimulator ( name : String ) : ActorBasic( name ) {
init{
	//autostart
	runBlocking{  autoMsg("simulatorstart","do") }
}

override suspend fun actorBody(msg : IApplMessage){
	println("$tt $name | received  $msg "  )
	if( msg.msgId() == "simulatorstart") startDataReadSimulation(   )
 }

suspend fun startDataReadSimulation(    ){
	//generate the distances to use (it goes from 80 to 20 and from 20 to 60)
	val data = generateSequence(80) { it - 5 }
	.takeWhile { it >= 20 }
	.toList() +
		generateSequence(20) { it + 5 }
			.takeWhile { it &lt;= 60 }
			.toList()
	var i = 0
		while( i &lt; 20 ){
			val m1 = "distance( ${data.elementAt(i)} )"
			i++
			val event = CommUtils.buildEvent( name,"sonardistance",m1)
			emitLocalStreamEvent( event )
			println("$tt $name | generates $event")
			//emit(event)  //APPROPRIATE ONLY IF NOT INCLUDED IN A PIPE
			delay( 1000 )
		}			
		terminate()
}
} 
		</code>
		</pre>
	  </div>
	  
	  <div class="flex-child right">
		<ul class="sep">
		<li>Questo semplice attore crea dati di distanza sintetici che vanno da 80 a 20 e da 20 a 60 e li emette come eventi locali.</li>
		</ul>
	  </div>
	</div>	
</div>
<h3 id="sonarhcsr">sonarHCSR04Support23.kt</h3>
Attore che riceve valori di distanza emessi da un sonar fisico (a cui ci si interfaccia tramite l'applicazione python <a href="#sonarpy"><b>sonar.py</b></a>) e
li trasmette alla pipeline.
<div class="sec remark-light">
<div class="flex-container">
	  <div class="flex-child left">
		<pre>
		<code>
class sonarHCSR04Support23 ( name : String ) : ActorBasic( name ) {
	lateinit var reader : BufferedReader
	//var coapSupport = javacode.CoapSupport("coap://localhost:8028","ctxsonarresource/sonarresource")
	init{
		//autostart
		runBlocking{  autoMsg("sonarstart","do") }
	}
    override suspend fun actorBody(msg : IApplMessage){
 		//println("$tt $name | received  $msg "  )  //RICEVE GLI EVENTI!!!
		if( msg.msgId() == "sonarstart"){
			//println("sonarHCSR04Support23 STARTING") //AVOID SINCE pipe ...
			try{
				//val p  = Runtime.getRuntime().exec("sudo ./SonarAlone")
				val p  = Runtime.getRuntime().exec("python sonar.py")
				reader = BufferedReader(  InputStreamReader(p.getInputStream() ))
				doRead(   )
			}catch( e : Exception){
				println("WARNING: $name does not find low-level code")
			}
 		}
     }
		
	suspend fun doRead(   ){
 		var counter = 0
		//GlobalScope.launch{	//to allow message handling
		GlobalScope.launch{
		while( true ){
				var data = reader.readLine()
				//CommUtils.outyellow("$name with python: data = $data"   )
				if( data != null ){
					try{
						val vd = data.toFloat()
						val v  = vd.toInt()
						if( v &lt;= 1000 ){	//A first filter ...
							val m1 = "distance( ${v} )"
							val event = MsgUtil.buildEvent( "sonarHCSR04Support","sonardistance",m1)
							//emit( event )  //should be propagated also to the remote resource
							emitLocalStreamEvent( event )		//not propagated to remote actors
							CommUtils.outyellow("sonarHCSR04Support23 doRead emits ${counter++}: $event "   )
						}
					}catch(e: Exception){
						CommUtils.outred("sonarHCSR04Support23 doRead ERROR: $e "   )
					}
				}
				//delay( 250 ) 	//Avoid too fast generation
 		}
		}
	}
}
		</code>
		</pre>
	  </div>
	  
	  <div class="flex-child right">
		<ul class="sep">
		<li>La classe effettua un primo filtraggio della distanza prima di emettere un evento locale propagato nella pipeline del sistema. </li>
		</ul>
	  </div>
	</div>	
</div>
<h3 id="datacleaner">dataCleaner.kt</h3>
Semplice attore che riceve valori emessi dall'attore <span class="blue">sonar</span>, li filtra in base ai valori di distanza e li trasmette alla pipeline.
li trasmette alla pipeline.
<div class="sec remark-light">
<div class="flex-container">
	  <div class="flex-child left">
		<pre>
		<code>
class dataCleaner (name : String ) : ActorBasic( name ) {
val LimitLow  = 2	
val LimitHigh = 1000
    override suspend fun actorBody(msg: IApplMessage) {
        if( msg.msgId() != "sonardistance") return
	    if( msg.msgSender() == name) return //AVOID to handle the event emitted by itself
  		elabData( msg )
 	}

	  suspend fun elabData( msg: IApplMessage){ //OPTIMISTIC
 		val data  = (Term.createTerm( msg.msgContent() ) as Struct).getArg(0).toString()
  		CommUtils.outyellow("$tt $name |  data = $data ")
		val Distance = Integer.parseInt( data ) 
 		if( Distance > LimitLow AND Distance &lt; LimitHigh ){
			emitLocalStreamEvent( msg ) //propagate
  	 	    val m0 = MsgUtil.buildEvent(name, "sonardata", "distance($data)")
		    //CommUtils.outgreen("$tt $name |  emits = $m0 ")
		    emit( m0 )    	
		  }else{
			//CommUtils.outmagenta("$tt $name |  DISCARDS $Distance ")
 		}				
 	}
}
		</code>
		</pre>
	  </div>
	  
	  <div class="flex-child right">
	  </div>
	</div>	
</div>

<h3 id="distancefilter">distanceFilter.kt</h3>
Semplice attore che riceve valori emessi dall'attore <span class="blue">datacleaner</span> e emette un evento <b>obstacle</b> o <b>free</b> in base al valore della distanza
ricevuta.
<div class="sec remark-light">
<div class="flex-container">
	  <div class="flex-child left">
		<pre>
		<code>
class distanceFilter (name : String ) : ActorBasic( name ) {
val DLIMT = 40
//@kotlinx.coroutines.ObsoleteCoroutinesApi

    override suspend fun actorBody(msg: IApplMessage) {
		if( msg.msgId() != "sonardata") return
		if( msg.msgSender() == name) return //AVOID to handle the event emitted by itself
  		elabData( msg )
 	}

  suspend fun elabData( msg: IApplMessage ){ //OPTIMISTIC
	  // if( msg.msgId() == "sonardata" ) return; //avoid ...
	val data  = (Term.createTerm( msg.msgContent() ) as Struct).getArg(0).toString()
	val Distance = Integer.parseInt( data )
/*
 * Emit a sonarRobot event to test the behavior with MQTT
 * We should avoid this pattern
*/	
 	 	//val m0 = MsgUtil.buildEvent(name, "sonardata", "distance($data)")
		//  CommUtils.outgreen("$tt $name |  emits = $m0 ")
		  //emit( m0 )
 		if( Distance > 0 AND Distance &lt; DLIMT ){
	 		val m1 = MsgUtil.buildEvent(name, "obstacle", "obstacle($data)")
			//CommUtils.outgreen("$tt $name |  emitLocalStreamEvent m1= $m1")
			emitLocalStreamEvent( m1 ) //propagate event obstacle
     	}else{
			val m2 = MsgUtil.buildEvent(name, "free", "free($data)")
			//CommUtils.outgreen("$tt $name |  emitLocalStreamEvent m2= $m2")
			emitLocalStreamEvent( m2 ) //propagate event free
 		}				
 	}
}
		</code>
		</pre>
	  </div>
	  
	  <div class="flex-child right">
	  </div>
	</div>	
</div>

<h3 id="alarmdevice">AlarmDevice</h3>
Attore che crea li pipeline di filtering delle distanze e invia i messaggi di stop e resume al ColdStorageService
<div class="sec remark-light">
<div class="flex-container">
	  <div class="flex-child left">
		<pre>
		<code>
QActor alarmdevice context ctxalarmdevice{ 
	[#	val MINT = 5					//seconds to wait before robot can be stopped again
		var stopped: Boolean = false 	//true if the robot is stopped
		var lastStopped = System.currentTimeMillis()	//when the robot got stopped the last time
		
	#]
	
	State s0 initial{  
		println("$name - START") color cyan
		[# subscribeToLocalActor("distancefilter").subscribeToLocalActor("datacleaner").subscribeToLocalActor("sonar") #]
	}
	Goto work
	
	State work{	
		updateResource [# "sonar23 waiting ..." #]
	}
	Transition t0 whenEvent obstacle  -> handleobstacle
	              whenEvent free	  -> handlefree
		
	State handleobstacle{
		onMsg( obstacle : obstacle(D)){
			[# val elapsedTime = (System.currentTimeMillis() - lastStopped) / 1000 //elapsed time in seconds #]
			if 	[# elapsedTime > MINT && !stopped #] {		
				println("$name - distance is: ${payloadArg(0)}, sending STOP message") color red
				forward fridgeservice -m stoptrolley : stoptrolley(stop)
				[# stopped = true
				   lastStopped = System.currentTimeMillis()
				#]
				updateResource [# "alarmdevice(stop)" #]
			}
			else {
				if [# stopped #] { 
					//println("$name - trolley already stopped") color cyan
				}
				else { 
					println("$name - $MINT seconds have to pass before stopping again") color cyan
					updateResource [# "alarmdevice(nostop)" #]
				}
			}
		}	
	}
	Goto work
	
	State handlefree{
		onMsg( free : free(D)){
			if [# stopped #] {
				[# stopped = false #]
				println("$name - distance is: ${payloadArg(0)}, sending RESUME message") color red
				forward fridgeservice -m resumetrolley : resumetrolley(resume)
				updateResource [# "alarmdevice(resume)" #]
			}
		}
	}
	Goto work
}
		</code>
		</pre>
	  </div>
	  
	  <div class="flex-child right">
	  <ul class="sep">
	  <li>Nello stato <b>s0</b> si crea la pipeline di filtering delle informazioni ricevute dal sonar.</li>
	  <li>In <b>work</b> si attende l'arrivo di uno dei due eventi obstacle e free. Se arriva obstacle si va nello stato <b>handleobstacle</b>, altrimenti in <b>handlefree</b>.</li>
	  <li>In <b>handleobstacle</b> si controlla se il trolley non è già stoppato (variabile stopped a true) e se sono passati <span class="red">MINT</span> secondi prima dell'ultimo
	  stop. In caso positivo si invia il dispatch <b>stoptrolley</b> al fridgeservice.</li>
	  <li>In <b>handlefree</b> si cambia il valore della variabile <b>stopped</b> e si invia un messaggio <b>resumetrolley</b> al fridgeservice.</li>
	  </ul>
	  </div>
	  
	</div>	
</div>
	  
<h3 id="warningdevice">WarningDevice</h3>
Attore che osserva il sistema ColdStorageService e accende e spegne un Led in base allo stato del trolley.
<div class="sec remark-light">
<div class="flex-container">
	  <div class="flex-child left">
		<pre>
		<code>
QActor warningdevice context ctxalarmdevice {
	[# var process = Runtime.getRuntime().exec("python LedOff.py") #]
	State s0 initial {
		println("$name - START") color magenta
		observeResource transporttrolley
		observeResource fridgeservice
	}
	Goto observing

	State observing{
	
	}
	Transition t0 whenMsg coapUpdate -> doObserve
	State doObserve{
		onMsg(coapUpdate : coapUpdate(transporttrolley, ARG)){
			[# var Message : String = "${payloadArg(1)}"
			   var Payload : String = SystemUtilities.getPayloadArgs(Message)[0]
			#]
			if [# Payload == "waitingRequest" || Payload == "atHome"#] {
				println("$name - LED OFF") color magenta
				[#
					process.destroy()
					process = Runtime.getRuntime().exec("python LedOff.py") 
				#]
				updateResource [# "warningdevice(off)" #]				
			}
			if [# Payload == "movingToIndoor" || Payload == "loadingCharge" || 
				Payload == "chargeTaken" || Payload == "movingToColdRoom"|| Payload == "depositingLoad"
				 || Payload == "MovingToHome" #] {
				 	println("$name - LED BLINKING") color magenta
				 	[#
						process.destroy()
						process = Runtime.getRuntime().exec("python LedBlink.py") 
					#]
				 	updateResource [# "warningdevice(blink)" #]
			}
		}
		onMsg(coapUpdate : coapUpdate(fridgeservice, ARG)){
			[# var Message : String = "${payloadArg(1)}"
			   var Payload : String = SystemUtilities.getPayloadArgs(Message)[0]
			#]
			if [# Payload == "stoppingTrolley"#] {
				println("$name - LED ON") color magenta
			[#
				process.destroy()
				process = Runtime.getRuntime().exec("python LedOn.py") 
			#]
				updateResource [# "warningdevice(on)" #]
			}
			if [# Payload == "resumingTrolley"#] {
				println("$name - LED BLINKING") color magenta
				[#
					process.destroy()
					process = Runtime.getRuntime().exec("python LedBlink.py") 
				#]
				updateResource [# "warningdevice(blink)" #]
			}		
		}
	}
  Goto observing
 }
		</code>
		</pre>
	  </div>
	  
	  <div class="flex-child right">
	  <ul class="sep">
	  <li>Nello stato <b>s0</b> l'attore inizia ad osservare il <span class="blue">TransportTrolley</span> e il <span class="blue">FridgeService</span>. Va poi
	  allo stato <b>Observing</b> dove attende un messaggio di <b>coapUpdate</b> per andare nello stato <b>doObserve</b></li>
	  <li>Nello stato <b>doObserve</b> si controlla il payload del messaggio coap arrivato e si aggiorna il led andando ad attivare il codice python relativo allo
	  stato in cui il led si deve trovare in base al messaggio arrivato. Il warningDevice effettua anche delle <b>updateResource</b> per far conoscere lo stato del led e
	  per essere utilizzato in sistemi di testing.</li>
	  </ul>
	  </div>
	  
	</div>	
</div>

<h3 id="sonarpy">sonar.py</h3>
Codice python per attivare il sonar fisico e ottenerne valori di distanza.
<div class="sec remark-light">
		<pre>
		<code>
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)
TRIG = 17
ECHO = 27

GPIO.setup(TRIG,GPIO.OUT)
GPIO.setup(ECHO,GPIO.IN)

GPIO.output(TRIG, False)   #TRIG parte LOW
#print ('Waiting a few seconds for the sensor to settle')
time.sleep(2)

while True:
   GPIO.output(TRIG, True)    #invia impulsoTRIG
   time.sleep(0.00001)
   GPIO.output(TRIG, False)

   #attendi che ECHO parta e memorizza tempo
   while GPIO.input(ECHO)==0:
      pulse_start = time.time()

   # register the last timestamp at which the receiver detects the signal.
   while GPIO.input(ECHO)==1:
      pulse_end = time.time()

   pulse_duration = pulse_end - pulse_start
   distance = pulse_duration * 17165   #distance = vt/2
   distance = round(distance, 1)
   #print ('Distance:',distance,'cm')
   print ( distance, flush=True ) 
   time.sleep(0.25)


#GPIO.cleanup()
		</code>
		</pre>
</div>

<h3 id="ledonpy">LedOn.py</h3>
Codice python per accendere un led fisico
<div class="sec remark-light">
		<pre>
		<code>
GPIO.setmode(GPIO.BCM)
GPIO.setup(25,GPIO.OUT)
 
try:
	GPIO.output(25,GPIO.HIGH)
except:
	print("LedDevice | An exception occurred")	
		</code>
		</pre>
</div>
<h3 id="ledoffpy">LedOff.py</h3>
Codice python per accendere un led fisico
<div class="sec remark-light">
		<pre>
		<code>
GPIO.setmode(GPIO.BCM)
GPIO.setup(25,GPIO.OUT)
 
try:
	GPIO.output(25,GPIO.LOW)
except:
	print("LedDevice | An exception occurred")	
		</code>
		</pre>
</div>
<h3 id="ledblinkpy">LedBlink.py</h3>
Codice python per accendere un led fisico
<div class="sec remark-light">
		<pre>
		<code>
GPIO.setmode(GPIO.BCM)
GPIO.setup(25,GPIO.OUT)
 
try:
	while True:
		GPIO.output(25,GPIO.HIGH)
		time.sleep(0.5)
		GPIO.output(25,GPIO.LOW)
		time.sleep(0.5)
except:
	print("LedDevice | An exception occurred")
		</code>
		</pre>
</div>

 <h2>Progettazione - ColdStorageService</h2>
<div class="sec remark-light">
I messaggi scambiati dal sistema <span class="blue">ColdStorageService</span> sono i seguenti:
</br>
<pre style="display:inline-block;">
<code>
//-------------------------Messaggi---------------------------------
Event alarm				: alarm(X) //stoppa il basicrobot

Dispatch stoptrolley : stoptrolley(ARG) //message sent from AlarmDevice to fridgeservice to stop trolley
Dispatch resumetrolley : resumetrolley(ARG) //message sent from AlarmDevice to fridgeservice to resume trolley
//------------------------------------------------------------------
</code>
</pre>
</br>
</div>
<h3>ServiceAccessGUI</h3>
<div class="sec remark-light">
	La <span class="blue">ServiceAccessGUI</span> è rimasta invariata rispetto allo <span class="red">SPRINT1</span>.
</div>
<h3>FridgeService</h3>
I cambiamenti effettuati al <span class="blue">FridgeService</span> rispetto allo <span class="red">SPRINT1</span> sono:
<div class="sec remark-light">
<div class="flex-container">
	  <div class="flex-child left">
		<pre>
		<code>
State waitRequest{
		println("$name - waiting for requests...") color blue
		updateResource [# "fridgeservice(waitingRequests)" #]
	}
	Transition t0 whenRequest storerequest -> handleRequest
					whenRequest sendticket -> handleTicket
					whenMsg stoptrolley -> handleStop
					whenMsg resumetrolley -> handleStop

State handleStop{
	onMsg(stoptrolley: stoptrolley(ARG)){
		println("$name - Stopping the trolley") color blue		
		forward transporttrolley -m stoptrolley: stoptrolley(ARG) //first we stop the trolley
		delay 100
		emit alarm : alarm(X) //then we stop the basicrobot
		updateResource [# "fridgeservice(stoppingTrolley)" #]
		
	}
	onMsg(resumetrolley: resumetrolley(ARG)){
		println("$name - Resuming the trolley") color blue
		forward transporttrolley -m resumetrolley: resumetrolley(ARG)
		updateResource [# "fridgeservice(resumingTrolley)" #]
	}	
}
Goto waitRequest
		</code>
		</pre>
	  </div>
	  
	  <div class="flex-child right">
		<ul class="sep">
		<li>Dallo stato <b>waitRequest</b> il fridgeservice può ora passare allo stato <b>handleStop</b> nel caso in cui gli arrivino i dispatch di <b>stoptrolley</b> o <b>resumetrolley</b></li>
		<li>Nello stato <b>handleStop</b> se il messaggio arrivato è <b>stoptrolley</b> si invia un dispatch di <b>stoptrolley</b> al <span class="blue">Trolley</span>, si attende
		una frazione di secondo e si invia l'evento <b>alarm</b> per far stoppare il <span class="blue">BasicRobot</span>. Se il messaggio arrivato è <b>resumetrolley</b> si
		inoltra il messaggio al <span class="blue">Trolley</span></li>
		</ul>
	  </div>
	</div>	
</div>

<h3>TransportTrolley</h3>
<div class="sec remark-light">
<div class="flex-container">
	  <div class="flex-child left">
		<pre>
		<code>
QActor transporttrolley context ctxcoldstorageservice{
	[# var LastAction = MoveType.MOVETOINDOOR //last action tried
	   var FailedCounter = 0 //number of failed moves
	   var Stopped : Boolean = false //whether or not the trolley is stopped
		#] 
	State s0 initial{
		println("$name - START, engage basicrobot") color green
		request basicrobot -m engage: engage(transporttrolley,330)
	}
	Transition s0 whenReply engagedone -> waitRequest
						whenReply engagerefused -> s0
	State waitRequest {
		if [# Stopped #] { [# Stopped = false #] } else {
			forward basicrobot -m setrobotstate : setpos(0,0,down) //just to be sure
		}
		println("$name - waiting for a request...") color green
		updateResource [# "transporttrolley(waitingRequest)" #]
		[# LastAction = MoveType.WAITREQUEST #]
	}
	Transition t0 whenMsg stoptrolley -> stop
					whenRequest takecharge -> moveToIndoor
					
		
	State moveToIndoor {
		if [# Stopped #] { [# Stopped = false #] } else {
			onMsg( takecharge : takecharge(TICKET) ){
				[# val Ticket="${payloadArg(0)}" #]			
				println("$name - moving to INDOOR to take charge of ticket $Ticket") color green
				updateResource [# "transporttrolley(movingToIndoor)" #]				
		  	}
		  	[# LastAction = MoveType.MOVETOINDOOR #]
		  	request basicrobot -m moverobot : moverobot (0,4) //(0,4) position of INDOOR in the map
      	}
							
	}
	Transition t0 whenMsg stoptrolley -> stop
					whenReply moverobotdone -> loadTheCharge
					whenReply moverobotfailed -> failedAction
					
	
	State loadTheCharge{
		if [# Stopped #] { [# Stopped = false #] } else {
			println("$name - loading charge ...") color green
			updateResource [# "transporttrolley(loadingCharge)" #]		
			delay 4000 //simulate the loading
			println("$name - taken charge of the load ...") color green
			updateResource [# "transporttrolley(chargeTaken)" #]
			replyTo takecharge with chargetaken: chargetaken(ARG) caller== fridgeservice
			[# LastAction = MoveType.LOADCHARGE #]
		}
	}
	
	Transition t0 whenTime 50 -> moveToColdRoom
					whenMsg stoptrolley -> stop
		
					
	
	State moveToColdRoom{
		if [# Stopped #] { [# Stopped = false #] } else {
			println("$name - moving to ColdRoom ...") color green
			updateResource [# "transporttrolley(movingToColdroom)" #]
			[# LastAction = MoveType.MOVETOCR #]
			request basicrobot -m moverobot: moverobot(4,3) //(4,3) position of PORT of coldroom
		}
	}
	Transition t0 whenMsg stoptrolley -> stop
					whenReply moverobotdone -> storeTheCharge
					whenReply moverobotfailed -> failedAction
					
						
	State storeTheCharge{
		if [# Stopped #] { [# Stopped = false #] } else {
			println("$name - depositing load ...") color green
			updateResource [# "transporttrolley(depositingLoad)" #]
			delay 4000 //simulate the deposit
			println("$name - load deposited ...") color green
			[# LastAction = MoveType.STORECHARGE #]
		}
	}
	Transition t0 whenTime 1000 -> moveToHome
					whenMsg stoptrolley -> stop
					whenRequest takecharge -> moveToIndoor			
				
	State moveToHome{
		if [# Stopped #] { [# Stopped = false #] } else {
			println("$name - No more requests, moving to home ...") color green
			updateResource [# "transporttrolley(movingToHome)" #]
			[# LastAction = MoveType.MOVETOHOME #]
			request basicrobot -m moverobot: moverobot (0,0) //(0,0) position of HOME
		}
	}
	Transition t0 whenMsg stoptrolley -> stop
					whenReply moverobotdone -> trolleyAtHome
					whenReply moverobotfailed -> failedAction
				
						
	State trolleyAtHome{
		println("$name - trolleyAtHome ... ") color green
		updateResource [# "transporttrolley(atHome)" #]
		forward basicrobot -m setdirection : dir(down)
		delay 1000 //To avoid interrupt of plan related to setDirection		
	}
	Goto exitSystem
	
	State failedAction{
		[# FailedCounter += 1 #]
		println("$name - The last action (${LastAction.name}) failed, trying again") color green
		forward transporttrolley -m tryagain : tryagain(ARG)
	}
	Transition t0
		whenMsg tryagain and [# FailedCounter >= 10 #] -> exitSystem
		whenMsg tryagain and [# LastAction == MoveType.MOVETOINDOOR #] -> moveToIndoor
		whenMsg tryagain and [# LastAction == MoveType.MOVETOCR #] -> moveToColdRoom
		whenMsg tryagain and [# LastAction == MoveType.MOVETOHOME #] -> moveToHome

	State stop{
		onMsg(stoptrolley: stoptrolley(ARG)){
			[# Stopped = true #]
			println("$name - STOPPED, waiting to be resumed") color green	
			updateResource [# "transporttrolley(stopped)" #]		
		}
	}
	Transition t0
		whenMsg resumetrolley and [# LastAction == MoveType.WAITREQUEST #] -> waitRequest
		whenMsg resumetrolley and [# LastAction == MoveType.MOVETOINDOOR #] -> moveToIndoor
		whenMsg resumetrolley and [# LastAction == MoveType.LOADCHARGE #] -> loadTheCharge
		whenMsg resumetrolley and [# LastAction == MoveType.MOVETOCR #] -> moveToColdRoom
		whenMsg resumetrolley and [# LastAction == MoveType.STORECHARGE #] -> storeTheCharge
		whenMsg resumetrolley and [# LastAction == MoveType.MOVETOHOME #] -> moveToHome
	
	State exitSystem {
		onMsg( tryagain : tryagain(ARG)){
			println("$name - Too many fails, exiting the system") color green
		}
		forward basicrobot -m disengage : disengage(transporttrolley)
		println("$name - disengaged") color green
		delay 1000 //avoid to premature abort of connection
		[# System.exit(0) #]
	}
}
		</code>
		</pre>
	  </div>
	  
	  <div class="flex-child right">
		<ul class="sep">
		<li>Tutti gli stati del Trolley che riguardano le azioni del robot ora hanno una transizione allo stato <b>stop</b> nel caso in cui arrivi il messaggio <b>stoptrolley</b>.
		Inoltre, gli stessi stati hanno anche un check iniziale che fa eseguire le operazioni dello stato solo se il trolley non era stato stoppato.</li>
		<li>Nello stato <b>stop</b> il trolley attende di essere riattivato. In base all'azione che stava eseguendo prima di essere stoppato, il trolley effettuerà una transizione
		a uno degli stati elencati quando riceve un messaggio di <b>resumetrolley</b>.</li>
		</ul>
	  </div>
	</div>	
</div>
 
 
 
 
 
<h2>Piani di testing</h2>
I test hanno la stessa struttura di osservatori CoaP che hanno nello SPRINT1.
Per effettuare i test si è realizzata una variante del modello del coldstorage (<a href="ColdStorageServiceModel/src/ColdStorageServiceModelTest.qak">ColdStorageServiceModelTest.qak</a>) in cui l'unica differenza è che la <span class="blue">ServiceAccessGUI</span> non invia nessun messaggio in maniera automatica (non simula l'interazione con il driver), in modo che possiamo
usare un test class per inviare e ricevere messaggi. E' stata realizzata anche una variante del modello dell'alarmdevice (<a href="AlarmDeviceModel/src/AlarmDeviceModelTest.qak">AlarmDeviceModelTest.qak</a>) in cui si usa il simulatore del sonar come attore <b>sonar</b> e gli indirizzi del coldstorageservice sono locali.

Al fine di testare il corretto funzionamento del sistema, sono stati introdotti i seguenti <b>piani di testing</b>, il primo realizzato per testare il <span class="blue">ColdStorageService</span> e il secondo per
testare l'<span class="blue">AlarmDevice</span>:
<div class="sec remark-light">
<ul class="sep">
<li><span class="remark">TestStopResume</span>: Test del normale funzionamento del sistema con comandi di stop e resume inviati dall'applicazione di test (si simula l'alarmdevice). Si invia una richiesta che non sfori il limite massimo della <b>coldRoom</b> e si verifica che il ticket venga accettato e che
il trolley ritorni correttamente nella home al termine dell'azione di deposito. Nel mentre vengono inviati messaggi di stop e resume per verificare che funzioni tutto comunque.</li>
</ul>
<div class="flex-container">
  <div class="flex-child left">
	<pre>
	<code>
@Test
    fun testRequestAccepted() {
        val conn: Interaction = ConnectionFactory.createClientSupport23(
            ProtocolType.tcp, "localhost", "9990")

        println("TestApplication - Sending store request of 30 kg")
        val storeRequest: IApplMessage = CommUtils.buildRequest("testApplication", "storerequest", "storerequest(30)", "fridgeservice")
        val storeReply: IApplMessage? = conn.request(storeRequest)
        val ticket: String = getPayloadArgs(storeReply?.msgContent())[0]

        //If everything goes as it should, the reply to the storerequest will be loadaccepted
        Assert.assertEquals("loadaccepted", storeReply?.msgId())

        println("TestApplication - Simulating going to indoor to send ticket")
        CommUtils.delay(4000)
        conn.forward("msg(sendticket,request,testApplication,fridgeservice,sendticket("+ticket+"),1)")

        //Send stop message
        CommUtils.delay(1000)
        conn.forward("msg(stoptrolley,dispatch,testApplication,fridgeservice,stoptrolley(stop),1)")

        //if got stopped correctly the service sent a stop message and the trolley is in stop state
        CommUtils.delay(1000)
        assertTrue("stoppingTrolley" in fridgeContentList)
        assertTrue("stopped" in trolleyContentList)

        //send resume
        CommUtils.delay(1000)
        conn.forward("msg(resumetrolley,dispatch,testApplication,fridgeservice,resumetrolley(resume),1)")
        //if got resumed correctly the service sent a resume message
        CommUtils.delay(1000)
        assertTrue("resumingTrolley" in fridgeContentList)

        //wait for the "at home" response of the robot
        var limit = 0
        while ( "atHome" !in trolleyContentList AND limit &lt; 15){
            limit += 1
            CommUtils.delay(2000)
        }

        //if everything goes as it should, the robot must reach home when it finishes
        assertTrue("atHome" in trolleyContentList)
    }
	</code>
	</pre>
  </div>
  
  <div class="flex-child right">
	<ul class="sep">
	<li>All'inizo del test si crea una connessione TCP con il contesto del <span class="blue">ColdStorageService</span>.</li>
	<li>Poi si crea e invia la richiesta <b>storeRequest</b> per un carico di 30kg, e si attende la risposta del sistema con il <b>ticket</b> da inserire. Poi si fa il check della risposta,
	che dovrebbe essere <b>loadaccepted</b>.</li>
	<li>In seguito si aspetta una quantità di tempo (minore del tempo massimo per inserire un biglietto) per simulare l'arrivo nella <span class="red">INDOOR</span> e si invia una nuova richiesta <b>sendticket</b> al sistema.</li>
	<li>Si aspetta un secondo e si simula l'invio di un messaggio <b>stoptrolley</b> da parte dell'alarmdevice. Se lo stop ha funzionato l'updateResource che il trolley chiama quando è nello stato di stop e quello che il fridge
	service chiama quando il stoppa il robot dovrebbero essere presenti nelle relative <b>ContentList</b>.</li>
	<li>Si aspetta un secondo e si simula l'invio di un messaggio <b>resumetrolley</b> da parte dell'alarmdevice. Se la resume ha funzionato l'updateResource che il fridgeservice chiama quando
	riattiva il trolley deve essere presente nella <b>fridgeContentList</b>.</li>
	<li>Infine si attende in un ciclo while che la test application riceva il messaggio <b>"at home"</b>, che viene inviato dal <span class="blue">TransportTrolley</span> quando tutte le richieste
	sono state eseguite e il trolley è tornato nella <span class="red">HOME</span>. Quindi se entro un certo tempo massimo questo messaggio arriva, significa che l'azione di deposito si è
	 conclusa correttamente (e che quindi il trolley è stato riattivato e di conseguenza anche il BasicRobot).</li>
	</ul>
  </div>
</div>

</div>
<div class="sec remark-light">
<ul class="sep">
<li><span class="remark">TestStopResumeAlarm</span>: Si testa il sistema <span class="blue">AlarmDevice</span> in locale per verificare che i messaggi di stop/resume vengano inviati
correttamente e che il led si accenda quando si invia un segnale di stop. Si testa inoltre che il messaggio di stop non deve essere inviato se non sono passati almeno <span class="red">MINT</span>
secondi dall'ultimo stop. Per effettuare questo test ho cambiato leggermente la classe <a href="#sonarsimulator"><b>sonarSimulator</b></a> in modo che invii distanze che arrivano sotto il limite <span class="red">DLIMIT</span>
2 volte, ma la seconda volta ci arriva in un tempo minore di <span class="red">MINT</span>, in modo da effettuare le giuste verifiche. </li>
</ul>
<div class="flex-container">
  <div class="flex-child left">
	<pre>
	<code>
@Test
    fun testStartStopAlarm() {

        //wait for the "nostop" response of the alarm
        var limit = 0
        while ( "nostop" !in alarmContentList AND limit &lt; 15){
            limit += 1
            CommUtils.delay(2000)
        }

        Assert.assertTrue("stop" in alarmContentList)
        Assert.assertTrue("resume" in alarmContentList)
        Assert.assertTrue("on" in warningContentList)
        Assert.assertTrue("nostop" in alarmContentList)

        //if everything goes as it should, the alarmContentlist should contain 1 time the stop message
        var count1 = alarmContentList.count { it == "stop" }
        Assert.assertEquals(1, count1)

        //if everything goes as it should, the alarmContentlist should contain 1 time the nostop message
        var count2 = alarmContentList.count { it.contains("nostop") }
        Assert.assertEquals(1, count2)

        //if everything goes as it should, the alarmContentlist should contain 1 time the resume message
        var count3 = alarmContentList.count { it.contains("resume") }
        Assert.assertEquals(1, count3)

        //if everything goes as it should, the warningContentlist should contain 1 time the on message
        var count4 = warningContentList.count { it.contains("on") }
        Assert.assertEquals(1, count4)

    }
	</code>
	</pre>
  </div>
  
  <div class="flex-child right">
	<ul class="sep">
	<li>Il test fa semplicemente partire il sistema (si suppone che il <span class="blue">ColdStorageService</span> sia attivato) e attende che arrivi il messaggio <b>nostop</b>.
	Questo messaggio viene inviato dall' <span class="blue">AlarmDevice</span> se si cerca di stoppare il Trolley prima del tempo <span class="red">MINT</span>.</li>
	<li>Poi si verifica che i messaggi <b>stop</b>,<b>resume</b>,<b>on</b>,<b>nostop</b> siano presenti nella lista dei messaggi ricevuti dall'osservatore coap. In particolare,
	<b>stop</b> (che è inviato dal alarmDevice quando invia un messaggio di stoptrolley) dovrà essere presente una volta nella lista, <b>resume</b> (che è inviato dal alarmDevice quando invia un messaggio di resumetrolley) dovrà
	essere presente una volta nella lista, <b>on</b> (che è inviato dal warningDevice quando accende il led) dovrà essere presente una volta nella lista, e lo stesso vale per <b>nostop</b>. </li>
	</ul>
  </div>
</div>

</div>


<h2>Piano di lavoro</h2>
Nello <span class="red">SPRINT3</span> si andrà a realizzare la <span class="blue">ServiceAccessGUI</span> come applicazione con interfaccia grafica.
Si rimuoverà quindi dal sistema l'attore che ha simulato il suo funzionamento e si rimpiazzerà con una webApplication che interagisce con il sistema attraverso scambio di
messaggi, e che fornirà una schermata grafica che permetterà all'utente di visualizzare il carico contenuto nella <b>ColdRoom</b> e di inviare <b>richieste di deposito</b> e <b>ticket</b> al sistema.


</div>
</body>
</html>
 
<!-- USEFUL
<table style="width:100%" border="1">
<tr>
<td style="width:50%">
</td>
<td></td>
</tr>
</table>
-->
	      	
<br/><br/> 	
</div>  

<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">
By Matteo Giri email: matteo.giri@studio.unibo.it
<br>
Link GitHub Repo: https://github.com/s1090263/iss2023/
<img src="../Sprint0/immagini/fotoGiriMatteo.jpg" alt="foto" width="20%" height="20%">
</div> 
</body>
</html>